
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>ABC378 题解报告 | yzljyのBlog</title>
    <meta name="author" content="yzljy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/yzljy.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YZLJYのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YZLJYのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>ABC378 题解报告</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/11/4
        </span>
        
        <span class="category">
            <a href="/categories/OI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                OI
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E9%A2%98%E8%A7%A3/" style="color: #ffa400">
                    题解
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%AF%94%E8%B5%9B/" style="color: #e74c3c">
                    比赛
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="闲话">闲话</h2>
<p>这次评分如下：<br />
<span
class="math inline">\(\text{NaN}-199-251-631-1378-1402-2932\)</span><br />
知道什么意思了吧（</p>
<h2 id="t1">T1</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_a">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_a">AT传送门</a></p>
<h3 id="题意">题意</h3>
<p>给你四个数 <span
class="math inline">\(a,b,c,d\)</span>，定义一次操作为：从剩下的数中中选出两个相同的数，并删除。问最多这样操作多少次。</p>
<h3 id="思路">思路</h3>
<p>因为只有四个数。<br />
我们可以暴力枚举每种情况，所以写起来并不是很麻烦。<br />
这里就不放代码了。</p>
<h3 id="扩展">扩展</h3>
<p>假如说不止四个数呢？</p>
<p>现在改为 <span class="math inline">\(n\)</span> 个数，每个数为 <span
class="math inline">\(val_{i}\)</span><br />
<span class="math inline">\(1 \le n \le 10^{5}\)</span><br />
<span class="math inline">\(1 \le val_{i} \le 10^{18}\)</span></p>
<p>这样又该怎么做呢？</p>
<p>其实也是很简单的。<br />
我们只需要统计每种数出现的次数，设为 <span
class="math inline">\(cnt_{val_{i}}\)</span>，因为每次只能删除相同的数，所以对于每种数，能贡献的答案就是
<span class="math inline">\(\left \lfloor \cfrac{cnt_{val_{i}}}{2}
\right \rfloor\)</span>。<br />
因为值域很大，可以使用 map 来存储。<br />
时间复杂度 <span class="math inline">\(O(n \log n)\)</span></p>
<h3 id="代码">代码</h3>
<pre class="cpp"><code>// Problem: A - Pairing
// Contest: AtCoder - AtCoder Beginner Contest 378
// URL: https://atcoder.jp/contests/abc378/tasks/abc378_a
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=1e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x)&#123;
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
&#125;
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y)&#123;
    read(x),read(y...);
&#125;

int a[MAXN],ans;
map&lt;int,int&gt; mp;

signed main()&#123;
    for(int i=1;i&lt;=n;i++) read(a[i]);
    for(int i=1;i&lt;=n;i++) mp[a[i]]++;
    for(int i=1;i&lt;=n;i++)&#123;
        ans+=mp[a[i]]/2;
        mp[a[i]]=0;
    &#125;
    cout&lt;&lt;ans;
    return 0;
&#125;</code></pre>
<p>原题中，把 <span class="math inline">\(n\)</span> 设置为 <span
class="math inline">\(4\)</span> 即可。</p>
<h2 id="t2">T2</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_b">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_b">AT传送门</a></p>
<h3 id="题意-1">题意</h3>
<p>给定两个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(q\)</span> 和 <span
class="math inline">\(r\)</span>。<br />
有 <span class="math inline">\(Q\)</span> 次询问，每次询问给出 <span
class="math inline">\(t_{i}\)</span> 和 <span
class="math inline">\(d_{i}\)</span>。<br />
每次询问需要求出最小的自然数 <span
class="math inline">\(val_{i}\)</span>，使得 <span
class="math inline">\(d_{i}+val_{i} \equiv r_{t_{i}} \pmod
{q_{t_{i}}}\)</span>。</p>
<h3 id="思路-1">思路</h3>
<p>根据题意，<span class="math inline">\(val_{i}\)</span> 一定小于 <span
class="math inline">\(q_{t_{i}}\)</span>，因此我们只需要分两种情况讨论即可。（以下的
<span class="math inline">\(d_{i}\)</span> 和 <span
class="math inline">\(r_{t_{i}}\)</span> 均是模 <span
class="math inline">\(q_{t_{i}}\)</span> 意义下的）</p>
<ul>
<li><span class="math inline">\(d_{i} &lt; r_{t_{i}}\)</span>
时：答案为后者减去前者</li>
<li>否则答案为上面再加上 <span
class="math inline">\(q_{t_{i}}\)</span></li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(Q)\)</span>。</p>
<h3 id="代码-1">代码</h3>
<pre class="cpp"><code>// Problem: B - Garbage Collection
// Contest: AtCoder - AtCoder Beginner Contest 378
// URL: https://atcoder.jp/contests/abc378/tasks/abc378_b
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=100+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x)&#123;
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
&#125;
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y)&#123;
    read(x),read(y...);
&#125;

int n,Q,r[MAXN],q[MAXN];

signed main()&#123;
    read(n);
    for(int i=1;i&lt;=n;i++) read(q[i],r[i]);
    read(Q);
    for(int i=1;i&lt;=Q;i++)&#123;
        int t,d;
        read(t,d);
        int val=d%q[t];
        if(val&lt;=r[t]) cout&lt;&lt;d+(r[t]-val)&lt;&lt;&#39;\n&#39;;
        else cout&lt;&lt;d+(r[t]+q[t]-val)&lt;&lt;&#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
<h2 id="t3">T3</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_c">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_c">AT传送门</a></p>
<h3 id="题意-2">题意</h3>
<p>给定义一个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span>。求对于 <span
class="math inline">\(a\)</span> 中的任意一个元素 <span
class="math inline">\(a_{i}\)</span>，找到最大的 <span
class="math inline">\(j &lt; i\)</span>，使得 <span
class="math inline">\(a_{i} = a_{j}\)</span>，若不存在这样的 <span
class="math inline">\(j\)</span>，则为 <span
class="math inline">\(-1\)</span>。</p>
<h3 id="思路-2">思路</h3>
<p>直接顺着题意模拟就行了。</p>
<p>可以像我一样开一个 map 来存，因为值域较大（<span
class="math inline">\(1 \le a_{i} \le 10^{9}\)</span>）。</p>
<p>时间复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>
<h3 id="代码-2">代码</h3>
<pre class="cpp"><code>// Problem: C - Repeating
// Contest: AtCoder - AtCoder Beginner Contest 378
// URL: https://atcoder.jp/contests/abc378/tasks/abc378_c
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=2e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x)&#123;
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
&#125;
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y)&#123;
    read(x),read(y...);
&#125;

int n,val[MAXN];
map&lt;int,int&gt; mp;

signed main()&#123;
    read(n);
    for(int i=1;i&lt;=n;i++) read(val[i]);
    for(int i=1;i&lt;=n;i++)&#123;
        if(mp.find(val[i])==mp.end()) cout&lt;&lt;-1;
        else cout&lt;&lt;mp[val[i]];
        cout&lt;&lt;&#39; &#39;;
        mp[val[i]]=i;
    &#125;
    return 0;
&#125;</code></pre>
<h2 id="t4">T4</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_d">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_d">AT传送门</a></p>
<h3 id="题意-3">题意</h3>
<p>给定一个长 <span class="math inline">\(H \times W\)</span>
的网格。网格中有些格子是障碍。现询问，从任意一个非障碍的格子开始，走恰好
<span class="math inline">\(K\)</span>
步，不走障碍格和已经走过的格子，一共有多少种方案。</p>
<p><span class="math inline">\(1 \le H,W \le 10\)</span><br />
<span class="math inline">\(1 \le K \le 11\)</span></p>
<h3 id="思路-3">思路</h3>
<p>如果使用 BFS 算法，暴力去做 <span class="math inline">\(H \times
W\)</span> 次的时间复杂度是 <span
class="math inline">\(O(H^{2}W^{2})\)</span> 的。（准确说应该是 <span
class="math inline">\(HW\)</span> 乘上这个点能在 <span
class="math inline">\(K\)</span> 步之内到达的点的数量）<br />
但是因为可以上下左右走，只要不走重复和障碍即可，BFS
的话并不是很好去统计方案数。（也可能是我太菜了xwx）</p>
<p>注意到数据范围很小。可以使用 <strong>回溯算法</strong> 计算。<br />
每次到一个点，先把这个点打上标记，然后查看周围四个点哪些点可以继续走。走到
<span class="math inline">\(K\)</span> 步的时候，将答案增加 <span
class="math inline">\(1\)</span> 即可。<br />
回溯的时候把标记取消了即可。</p>
<p>设一个点的方案数为 <span
class="math inline">\(val_{i,j}\)</span>，则时间时间复杂度至少为（因为会走错误路线）。<br />
<span class="math display">\[
O(\sum^{H}_{i=1}\sum^{W}_{j=1}val_{i,j})
\]</span></p>
<p>不妨跑一下极限数据，即 <span class="math inline">\(10 \times
10\)</span> 的网格，走 <span class="math inline">\(11\)</span>
步，并且没有障碍。我这里跑出来 DFS 函数也只会调用不到 <span
class="math inline">\(7\times 10^{6}\)</span>
次，因此时间复杂度是没有问题的。</p>
<h3 id="代码-3">代码</h3>
<pre class="cpp"><code>// Problem: D - Count Simple Paths
// Contest: AtCoder - AtCoder Beginner Contest 378
// URL: https://atcoder.jp/contests/abc378/tasks/abc378_d
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=10+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x)&#123;
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
&#125;
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y)&#123;
    read(x),read(y...);
&#125;

int h,w,k,ans;
char g[MAXN][MAXN];
bool vis[MAXN][MAXN];

struct node&#123;
    int x,y,dis;
&#125;;

void dfs(int x,int y,int dis)&#123;
    if(dis==k)&#123;
        ans++;
        return;
    &#125;
    vis[x][y]=true;
    if(x!=1&amp;&amp;!vis[x-1][y]&amp;&amp;g[x-1][y]==&#39;.&#39;) dfs(x-1,y,dis+1);
    if(x!=h&amp;&amp;!vis[x+1][y]&amp;&amp;g[x+1][y]==&#39;.&#39;) dfs(x+1,y,dis+1);
    if(y!=1&amp;&amp;!vis[x][y-1]&amp;&amp;g[x][y-1]==&#39;.&#39;) dfs(x,y-1,dis+1);
    if(y!=w&amp;&amp;!vis[x][y+1]&amp;&amp;g[x][y+1]==&#39;.&#39;) dfs(x,y+1,dis+1);
    vis[x][y]=false;
&#125;

signed main()&#123;
    cin&gt;&gt;h&gt;&gt;w&gt;&gt;k;
    for(int i=1;i&lt;=h;i++) for(int j=1;j&lt;=w;j++) cin&gt;&gt;g[i][j];
    for(int i=1;i&lt;=h;i++)&#123;
        for(int j=1;j&lt;=w;j++)&#123;
            if(g[i][j]==&#39;#&#39;) continue;
            dfs(i,j,0);
        &#125;
    &#125;
    cout&lt;&lt;ans;
    return 0;
&#125;</code></pre>
<h2 id="t5">T5</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_e">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_e">AT传送门</a></p>
<h3 id="题意-4">题意</h3>
<p>给一个长为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span>，求其所有子段和对 <span
class="math inline">\(m\)</span> 取模后的和。</p>
<p><span class="math inline">\(1 \le n \le 2 \times
10^{5}\)</span><br />
<span class="math inline">\(1 \le m \le 2 \times 10^{5}\)</span><br />
<span class="math inline">\(1 \le a_{i} \le 10^{9}\)</span></p>
<h3 id="思路-4">思路</h3>
<p>因为子段和可以转化为前缀和之差。<br />
所以我们可以先对 <span class="math inline">\(a\)</span>
数组做前缀和，记作 <span class="math inline">\(pre\)</span> 数组。</p>
<p>考虑枚举右端点，每次统计所有以右端点结尾的子段的答案和。<br />
先考虑暴力枚举左端点。设当前右端点为 <span
class="math inline">\(r\)</span>，左端点为 <span
class="math inline">\(l\)</span>。<br />
有这么两种情况：</p>
<ul>
<li><span class="math inline">\(pre_{r}-pre_{l-1} \ge
0\)</span>，这种情况直接统计答案即可。</li>
<li><span class="math inline">\(pre_{r}-pre_{l-1} &lt;
0\)</span>，这种情况值加上 <span class="math inline">\(m\)</span>
再统计即可。</li>
</ul>
<p>时间复杂度 <span
class="math inline">\(O(n^{2})\)</span>，考虑优化。</p>
<p>现在我们实际上将 <span class="math inline">\(a_{i}\)</span>
的范围变成了 <span class="math inline">\(0 \le a_{i} &lt;
m\)</span>，而上面两种情况，其实就是对值小于等于 <span
class="math inline">\(pre_{r}\)</span>
的数统计一种答案，再对大于的统计另一种答案。<br />
那么我们可以用树状数组来优化这一过程。</p>
<p>具体实现上：<br />
我们可以开两个值域树状数组，一个存储值的和，记作 <span
class="math inline">\(sum\)</span>，一个存储值的个数，记作 <span
class="math inline">\(cnt\)</span>。<br />
对于第一种情况，那就是 <span class="math inline">\(cnt_{pre_{r}} *
pre_{r} - sum_{pre_{r}}\)</span>，第二种情况是类似的，只是加上 <span
class="math inline">\(cnt_{pre_{r}} * m\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n \log V)\)</span></p>
<h3 id="代码-4">代码</h3>
<pre class="cpp"><code>// Problem: E - Mod Sigma Problem
// Contest: AtCoder - AtCoder Beginner Contest 378
// URL: https://atcoder.jp/contests/abc378/tasks/abc378_e
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=2e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x)&#123;
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
&#125;
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y)&#123;
    read(x),read(y...);
&#125;

int n,m,ans,val[MAXN];

int lowbit(int u)&#123;
    return u&amp;(-u);
&#125;

struct node&#123;
    int a[MAXN];
    void init()&#123;
        for(int i=1;i&lt;=2e5;i++) a[i]=0;
    &#125;
    void update(int pos,int val)&#123;
        while(pos&lt;=2e5)&#123;
            a[pos]+=val;
            pos+=lowbit(pos);
        &#125;
    &#125;
    int query(int pos)&#123;
        int res=0;
        while(pos)&#123;
            res+=a[pos];
            pos-=lowbit(pos);
        &#125;
        return res;
    &#125;
&#125;t,cnt;


signed main()&#123;
    read(n,m);t.init();cnt.init();
    for(int i=1;i&lt;=n;i++) read(val[i]);
    for(int i=1;i&lt;=n;i++) val[i]%=m;
    for(int i=1;i&lt;=n;i++) val[i]=(val[i]+val[i-1])%m;
    t.update(1,1);cnt.update(1,1);
    for(int i=1;i&lt;=n;i++)&#123;
        int z=val[i]+1;
        ans+=cnt.query(z)*(z)-t.query(z);
        ans+=(cnt.query(2e5)-cnt.query(z))*(m+z)-(t.query(2e5)-t.query(z));
        t.update(z,z);
        cnt.update(z,1);
    &#125;
    cout&lt;&lt;ans;
    return 0;
&#125;</code></pre>
<h2 id="t6">T6</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_f">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_f">AT传送门</a></p>
<h3 id="题意-5">题意</h3>
<p>给定一棵 <span class="math inline">\(n\)</span>
个点的无根树，从中任选 <span class="math inline">\(2\)</span> 个点 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j(i&lt;j)\)</span>，连接这两个点后，会构成一个环，若环上所有点的度数均为
<span
class="math inline">\(3\)</span>，那么这个连接方案是合法的，问有多少种合法的方案。（要求连接后的图是简单图）</p>
<p><span class="math inline">\(3 \le n \le 2 \times 10^{5}\)</span></p>
<h3 id="思路-5">思路</h3>
<p>连接树上两个点 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 后，形成的环上的点其实就是原本 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span>
的简单路径上的点，度数是原本这些点的度数，只有 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 的度数会增加 <span
class="math inline">\(1\)</span>。<br />
因此，本质上求的是有多少条树上的简单路径，使得该路径的两端点度数为 <span
class="math inline">\(2\)</span>，该路径上其他点度数为 <span
class="math inline">\(3\)</span>。<br />
而简单图的限制其实就是不能选相邻两个点，因为这样会造成重边，图就不是简单图了。</p>
<p>那么我们怎么去求这些满足条件的路径个数呢？</p>
<p>我们只需要找出所有极大的连通块，这些连通块内的点度数均为 <span
class="math inline">\(3\)</span>。那么对于每一个极大的连通块，与其相连的点中，任意两两度数为
<span class="math inline">\(2\)</span> 的点，均可以构成一条路径。</p>
<p>怎么去求得这个答案呢？</p>
<p>可以考虑先将原本的树删掉部分点，只剩下度数为 <span
class="math inline">\(2\)</span> 和 <span
class="math inline">\(3\)</span>
的点。然后再去统计答案。这种方法我没写。</p>
<p>也可以像我一样。记录下每个内部点的度数均为 <span
class="math inline">\(3\)</span>
的极大连通块的编号，再看它周围有多少度数为 <span
class="math inline">\(2\)</span> 的点，统计一下，最后计算答案即可。使用
DFS 即可。具体可以看代码。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span></p>
<h3 id="代码-5">代码</h3>
<pre class="cpp"><code>// Problem: F - Add One Edge 2
// Contest: AtCoder - AtCoder Beginner Contest 378
// URL: https://atcoder.jp/contests/abc378/tasks/abc378_f
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN=2e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x)&#123;
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
&#125;
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y)&#123;
    read(x),read(y...);
&#125;

int n,k,ans,cnt,tot[MAXN],belong[MAXN],head[MAXN],d[MAXN];
bool vis[MAXN];
struct node&#123;
    int to,next;
&#125;edge[MAXN&lt;&lt;1];

void build(int u,int v)&#123;
    edge[++k].to=v;
    edge[k].next=head[u];
    head[u]=k;
&#125;

void dfs(int u)&#123;
    vis[u]=true;
    if(d[u]==3&amp;&amp;belong[u]==0) belong[u]=++cnt;
    //假如u这个点的度数是3，但是目前没有属于任意极大一个连通块，那么说明从它开始是一个极大连通块。
    for(int i=head[u];i;i=edge[i].next)&#123;
        int v=edge[i].to;
        if(d[u]==3&amp;&amp;d[v]==2) tot[belong[u]]++;
        //将符合条件的度数为2的点的个数记录下来
        if(vis[v]) continue;
        //注意: 一个度数为3的点的父亲的度数可能为2,这依然是需要统计的。
        //因此应该先统计，再判断是否访问过。
        if(d[v]==3&amp;&amp;d[u]==3) belong[v]=belong[u];
        //将与u相邻的点中度数为3的归到同一极大连通块中。
        dfs(v);
    &#125;
&#125;

signed main()&#123;
    read(n);
    for(int i=1;i&lt;n;i++)&#123;
        int u,v;
        read(u,v);
        build(u,v);
        build(v,u);
        d[u]++;d[v]++;
    &#125;
    dfs(1);
    for(int i=1;i&lt;=cnt;i++) ans+=tot[i]*(tot[i]-1)/2;
    //统计答案
    cout&lt;&lt;ans;
    return 0;
&#125;</code></pre>
<h2 id="t7">T7</h2>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc378_g">洛谷传送门</a><br />
<a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc378/tasks/abc378_g">AT传送门</a></p>
<p>不会捏 xwx<br />
突然难度飙升到 2900，场切人数只有 18 人。<br />
后来尝试看了一下题解，发现一堆不知道的东西，也就没管了xwx。<br />
如果有人会的，欢迎来给我讲解（不是</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2025 yzljyのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yzljy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="yzljyawa/yzljyawa.github.io"
    data-repo-id="R_kgDOMbAUfA"
    data-category="Announcements"
    data-category-id="DIC_kwDOMbAUfM4CiQYe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
