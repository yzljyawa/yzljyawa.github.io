
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>LCT/Splay 学习笔记 | yzljyのBlog</title>
    <meta name="author" content="yzljy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/yzljy.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YZLJYのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YZLJYのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>LCT/Splay 学习笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/1
        </span>
        
        <span class="category">
            <a href="/categories/OI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                OI
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" style="color: #979a9a">
                    学习指南
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/LCT/" style="color: #e74c3c">
                    LCT
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="color: #a5ff4d">
                    平衡树
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="是什么">是什么</h1>
<p>Link-Cut-Tree 一般称作
<code>LCT</code>/<code>虚实链剖分</code>。<br />
（ps： LCT 不能称作 <code>动态树</code>，<code>动态树</code>
指的是一类问题。）<br />
由 Tarjan
发明（对，又是他），用于解决动态的树上路径/子树问题（统称为<strong>动态树</strong>问题）。<br />
对于普通的树上问题，比如：</p>
<blockquote>
<p>给定一颗 <span class="math inline">\(n\)</span>
个节点的树，每个节点均有权值，需要维护三个操作：<br />
1.查询 <span class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 路径上的权值和<br />
2.查询以 <span class="math inline">\(u\)</span> 为根的子树的权值和<br />
3.将 <span class="math inline">\(u\)</span> 点的权值修改为 <span
class="math inline">\(val\)</span></p>
</blockquote>
<p>那么这是一道很板的树链剖分题。<br />
但假如我们还需要维护两个操作：</p>
<blockquote>
<p>4.将 <span class="math inline">\(u,v\)</span>
这条边断开（如果有边的话）<br />
5.将 <span class="math inline">\(u,v\)</span> 连接起来（若 <span
class="math inline">\(u,v\)</span> 不在同一连通块内）</p>
</blockquote>
<p>那么现在，普通的树剖就没有办法解决了。这时候，我们就需要用到
LCT。</p>
<h1 id="怎么做">怎么做</h1>
<p><strong>变量声明</strong></p>
<blockquote>
<p><span class="math inline">\(root\)</span> 表示树的根<br />
<span class="math inline">\(tot\)</span> 表示当前树的节点个数<br />
<span class="math inline">\(val_{i}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的权值<br />
<span class="math inline">\(son_{i,0}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的左儿子<br />
<span class="math inline">\(son_{i,1}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的右儿子<br />
<span class="math inline">\(fa_{i}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的父亲<br />
<span class="math inline">\(tag_{i}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的翻转标记<br />
<span class="math inline">\(cnt_{i}\)</span> 表示 <span
class="math inline">\(i\)</span>
节点存储的数量（同样的值放在同一个节点）<br />
<span class="math inline">\(siz_{i}\)</span> 表示以 <span
class="math inline">\(i\)</span> 节点为根的子树大小</p>
</blockquote>
<p>先将 LCT 模板题放在 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3690">这里</a>。<br />
其实 LCT 的码量并不算太大，但是就比较难理解。</p>
<p>前置芝士：二叉搜索树，Splay。</p>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>我们在对一个序列进行各种操作的时候，可能会遇见让你插入某个数，删除某个数，还需要让你随时都保证有序，假如我们对一个普通的数组这样操作的话，如果从中间插入和删除之类的，需要用到
<span class="math inline">\(O(n)\)</span>
的时间来维护序列的有序，这样的时间复杂度是无法接受的。于是我们将序列转移到一颗二叉树上。</p>
<h3 id="输出">输出</h3>
<p>我们不妨让二叉树的中序遍历的结果，就是原先的序列。</p>
<p>那么怎么维护有序？假设我们需要维护单调递增的序列，对于每个节点 <span
class="math inline">\(i\)</span> 都满足 <span
class="math inline">\(val_{son_{i,0}} &lt; val_{i} &lt;
val_{son_{i,1}}\)</span> 即可。</p>
<p>这样的话，经过中序遍历后得到的结果，就是单调递增的原序列了。</p>
<h3 id="插入">插入</h3>
<p>设插入的值为 <span class="math inline">\(v\)</span>。<br />
根据前面所讲的输出方式，我们在插入的时候，使二叉树依然满足性质即可。<br />
最开始令 <span class="math inline">\(pos \gets root\)</span>。<br />
（ps：<span class="math inline">\(a \gets b\)</span> 表示将 <span
class="math inline">\(b\)</span> 的值赋给 <span
class="math inline">\(a\)</span>）<br />
一直重复下面这个式子，直到 <span
class="math inline">\(pos=0\)</span>，或者 <span
class="math inline">\(val_{pos}=v\)</span>。</p>
<p><span class="math display">\[
\begin{cases}
  pos \gets son_{pos,0}(v&lt;val_{pos})\\
  pos \gets son_{pos,1}(v&gt;val_{pos})
\end{cases}
\]</span></p>
<p>找到插入的位置后，如果 <span
class="math inline">\(pos=0\)</span>，我们就可以将 <span
class="math inline">\(tot \gets tot+1\)</span> 并将新的这个权值 <span
class="math inline">\(v\)</span> 赋给 <span
class="math inline">\(val_{tot}\)</span>，再更新 <span
class="math inline">\(fa_{tot}\)</span> 和 <span
class="math inline">\(son_{fa_{tot},0/1}\)</span>。如果 <span
class="math inline">\(pos\not =0\)</span>，那我们只需要将 <span
class="math inline">\(cnt_{pos} \gets cnt_{pos}+1\)</span> 即可。<br />
这样插入操作就完成了！<br />
代码如下：</p>
<pre class="cpp"><code>void insert(int v)&#123;
    int pos=root;
    int f=0;
    while(true)&#123;
        if(pos==0)&#123;
            val[++tot]=v;
            fa[tot]=f;
            if(f!=0) son[f][v&gt;val[f]]=v;
            break;
        &#125;
        fa=pos;
        if(v==val[pos])&#123;
            cnt[pos]++;
            break;
        &#125;
        pos=son[pos][v&gt;val[pos]];
    &#125;
&#125;</code></pre>
<h3 id="查找某个值所在的位置">查找某个值所在的位置</h3>
<p>设需要查找的值为 <span class="math inline">\(v\)</span>（保证 <span
class="math inline">\(v\)</span> 存在）。<br />
那么就和插入操作很类似了，只是我们当 <span
class="math inline">\(v=val_{pos}\)</span> 的时候，直接返回 <span
class="math inline">\(pos\)</span> 即可<br />
代码如下：</p>
<pre class="cpp"><code>int selpos(int v)&#123;
    int pos=root;
    while(true)&#123;
        if(val[pos]==v) return pos;
        pos=son[pos][v&gt;val[pos]];
    &#125;
&#125;</code></pre>
<h3 id="删除">删除</h3>
<p>设需要删除的值为 <span class="math inline">\(v\)</span>。<br />
删除操作需要先找到 <span class="math inline">\(v\)</span>
的位置，删除后，合并他的左右两颗子树即可。<br />
代码如下：</p>
<pre class="cpp"><code>void clear(int pos)&#123;
    val[pos]=son[pos][0]=son[pos][1]=fa[pos]=0;
&#125;//清空节点pos
void del(int v)&#123;
    int pos=selpos(v);
    if(son[pos][0]==0&amp;&amp;son[pos][1]==0)&#123;
        clear(pos);
        return;
    &#125;
    if(son[pos][0]==0&amp;&amp;son[pos][1]!=0)&#123;
        fa[son[pos][1]]=fa[pos];
        if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][1];
        clear(pos);
        return;
    &#125;
    if(son[pos][0]!=0&amp;&amp;son[pos][1]==0)&#123;
        fa[son[pos][0]]=fa[pos];
        if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][0];
        clear(pos);
        return;
    &#125;
    fa[son[pos][0]]=son[pos][1];
    fa[son[pos][1]]=fa[pos];
    if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][1];
    clear(pos);
&#125;</code></pre>
<h3 id="更多操作">更多操作</h3>
<ul>
<li>查询 <span class="math inline">\(v\)</span> 这个值的排名<br />
</li>
<li>查询 <span class="math inline">\(x\)</span> 这个排名的值<br />
</li>
<li>查询 <span class="math inline">\(v\)</span> 这个值的前驱<br />
</li>
<li>查询 <span class="math inline">\(v\)</span> 这个值的后继</li>
</ul>
<p>请读者自行尝试或者查阅，因为普通的二叉搜索树可以被很容易的卡成 <span
class="math inline">\(O(n)\)</span> 的，因此在后文讲解 Splay
时再具体讲解这些操作。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>空间复杂度：</p>
<blockquote>
<p>我们每次在插入时只会多一个，因此空间复杂度为 <span
class="math inline">\(O(n)\)</span>。</p>
</blockquote>
<p>时间复杂度：</p>
<blockquote>
<p>理想情况下，<span class="math inline">\(n\)</span>
个数据构成的二叉树的高度为 <span
class="math inline">\(O(\log{n})\)</span>，因此在插入删除时均最多跳
<span class="math inline">\(O(\log{n})\)</span> 次，最优时间复杂度为
<span class="math inline">\(O(\log{n})\)</span>。<br />
但是我们可以通过构造如 <code>1 2 3 4 5</code>
这样单调的数据，来使树高变为 <span
class="math inline">\(O(n)\)</span>，此时二叉搜索树退化为<strong>链</strong>，插入和删除时最多会跳
<span class="math inline">\(n\)</span> 次，最劣时间复杂度为 <span
class="math inline">\(O(n)\)</span>。</p>
</blockquote>
<p>总之，普通的二叉搜索树没法保证时间复杂度，我们需要优化。</p>
<h2 id="splay">Splay</h2>
<p>Splay 是一种自平衡的二叉搜索树。<br />
（ps：关于更多平衡树，以后会讲）</p>
<p>Splay 通过一种叫做 <code>Splay</code>
的操作，防止二叉搜索树退化为链，保证了树高为 <span
class="math inline">\(O(\log{n})\)</span> 级别，保证了各个操作的 <span
class="math inline">\(O(\log{n})\)</span> 时间复杂度。</p>
<h3 id="基础操作">基础操作</h3>
<p>直接上代码吧：</p>
<pre class="cpp"><code>void clear(int x)&#123;
    fa[x]=val[x]=son[x][0]=son[x][1]=cnt[x]=siz[x]=0;
&#125;//清空x节点
void pushup(int x)&#123;
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];
&#125;//更新x节点的子树大小
bool get(int x)&#123;
    return x==son[fa[x]][1];
&#125;//得到点x属于fa[x]的左儿子还是右儿子</code></pre>
<h3 id="旋转操作">旋转操作</h3>
<p>若你学过 Treap 之类的带旋平衡树，这一部分可以选择略过。</p>
<p>由中序遍历的性质：同一种中序遍历对应的二叉树不止一棵。<br />
我们可以通过一些操作，在保证中序遍历不变的前提下，来使树高变低。<br />
这种操作就称作 <code>旋转操作</code>，函数一般叫做
<code>rotate</code>。</p>
<h4 id="为什么要旋转">为什么要旋转</h4>
<p>对于这么一棵二叉树。</p>
<p><img src="/images/LCT1.png" /></p>
<p>我们要将其转成这样：</p>
<p><img src="/images/LCT2.png" /></p>
<p>当然也可以转回来。<br />
这样进行一次旋转后，x的高度提高了一层，看似对总的高度没有影响，但对于这样的退化成链的情况时：</p>
<p><img src="/images/LCT3.png" /></p>
<p>我们可以通过如下操作，将高度降低。</p>
<ol type="1">
<li>对点 <span class="math inline">\(1\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT4.png" /></p>
<ol start="2" type="1">
<li>再对点 <span class="math inline">\(1\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT5.png" /></p>
<ol start="3" type="1">
<li>继续对点 <span class="math inline">\(1\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT6.png" /></p>
<ol start="4" type="1">
<li>最后对点 <span class="math inline">\(3\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT7.png" /></p>
<p>至此，我们成功地通过旋转操作将高度从 <span
class="math inline">\(4\)</span> 降到 <span
class="math inline">\(3\)</span>。<br />
因此旋转操作是可以有效降低树高的。</p>
<h4 id="旋转过程讲解">旋转过程讲解</h4>
<p>我们令要进行 <code>rotate</code> 操作的点为 <span
class="math inline">\(x\)</span>。<br />
令:<br />
<span class="math inline">\(y \gets fa_{x}\)</span><br />
<span class="math inline">\(z \gets fa_{y}\)</span><br />
<span class="math inline">\(ch \gets get(x)\)</span></p>
<p>根据这两个图：</p>
<p><img src="/images/LCT1.png" /></p>
<p><img src="/images/LCT2.png" /></p>
<p>我们可以发现：<br />
（ps：<span class="math inline">\(a \oplus b\)</span> 表示 "<span
class="math inline">\(a\)</span> 异或 <span
class="math inline">\(b\)</span>"）<br />
（此时的 <span class="math inline">\(ch=0\)</span>）</p>
<ul>
<li><span class="math inline">\(son_{x,ch}\)</span> 没有发生变化<br />
</li>
<li><span class="math inline">\(son_{x,ch \oplus 1}\)</span> 变成了
<span class="math inline">\(y\)</span><br />
</li>
<li><span class="math inline">\(son_{y,ch}\)</span> 从 <span
class="math inline">\(x\)</span> 变成了 <span
class="math inline">\(son_{x,ch \oplus 1}\)</span><br />
</li>
<li>对应的 <span class="math inline">\(fa\)</span>
的的值也会随之变化</li>
</ul>
<p>最后再处理一下先后执行顺序，就可以写出旋转操作的代码啦~~</p>
<h4 id="代码">代码</h4>
<pre class="cpp"><code>void rotate(int x)&#123;
    int y=fa[x],z=fa[y];bool ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]!=0) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[y]=x;
    fa[x]=z;
    if(z!=0) son[z][y==son[z][1]]=x;
    pushup(y);
    pushup(x);
&#125;</code></pre>
<h3 id="splay操作">Splay操作</h3>
<p>Splay 规定，每次操作后，都要将操作的点转到根上，这样的操作就被称为
<code>Splay操作</code>。<br />
怎么转移到根上？暴力一次次往上旋转即可。</p>
<h4 id="单旋splay">单旋Splay</h4>
<p>如果只是像上文那样旋转，也就是从下往上依次转，这样的被称为
<code>单旋Splay</code>。<br />
当出现 <span class="math inline">\(x,y,z\)</span>
三点共线时，我们发现，依此转完后，树高是没有变化的，这样就没法保证时间复杂度（见下面几张图理解）。</p>
<p><img src="/images/LCT8.png" /></p>
<p>我们需要将 <span class="math inline">\(1\)</span> 号点转到根上。</p>
<p>那么我们只需要旋转四次 <span class="math inline">\(1\)</span>
号点就可以了。<br />
转的过程如下：</p>
<p><img src="/images/LCT9.png" /></p>
<p><img src="/images/LCT10.png" /></p>
<p><img src="/images/LCT11.png" /></p>
<p><img src="/images/LCT12.png" /></p>
<p>这样的话，就是“如转”，我们虽然将 <span
class="math inline">\(1\)</span>
号点转到了根上，但是高度并没有降低。<br />
因此当树退化为一条链的时候，<code>单旋Splay</code>
也就没法保证时间复杂度了。</p>
<p>这时候我们就需要用到 <code>双旋Splay</code>。</p>
<h4 id="双旋splay">双旋Splay</h4>
<p><code>双旋Splay</code> 其实就是在 <code>单旋Splay</code>
的基础上，特殊处理了一下 <span class="math inline">\(u,v,z\)</span>
三点共线的情况。<br />
在遇到三点共线的情况时，我们只需要先旋转 <span
class="math inline">\(fa_{u}\)</span> 也就是 <span
class="math inline">\(v\)</span> 点，再旋转 <span
class="math inline">\(u\)</span> 点即可。<br />
因为我们在旋转某个点的时候，这个点的整个子树都会一起上升 <span
class="math inline">\(1\)</span> 层。<br />
因此我们先转 <span class="math inline">\(v\)</span>，后转 <span
class="math inline">\(u\)</span> 是合法的。<br />
（见下图模拟，我们依然需要将 <span class="math inline">\(1\)</span>
号点转到根上）</p>
<p><img src="/images/LCT8.png" /></p>
<p><span class="math inline">\(1,2,3\)</span> 号点共线，因此先转 <span
class="math inline">\(2\)</span> 号点，再转 <span
class="math inline">\(1\)</span> 号点。</p>
<p><img src="/images/LCT13.png" /></p>
<p><img src="/images/LCT14.png" /></p>
<p><span class="math inline">\(1,4,5\)</span> 号点共线，因此先转 <span
class="math inline">\(4\)</span> 号点，再转 <span
class="math inline">\(1\)</span> 号点。</p>
<p><img src="/images/LCT15.png" /></p>
<p><img src="/images/LCT16.png" /></p>
<p>可见，<code>双旋Splay</code>
不仅将我们需要的点转到了根上，而且将原来的不优美的链，变得优美了一些些，高度也就降低了，因此
<code>双旋Splay</code> 更优。</p>
<pre class="cpp"><code>//这里的to表示要转到哪个点去，一般是转到根，也就是to==root
void Splay(int x,int &amp;to)&#123;
    int z=fa[to];
    for(int f=fa[x];f!=z;f=fa[x])&#123;
        if(fa[f]!=z) rotate(get(x)==get(f)?f:x);
        rotate(x);
    &#125;
    to=x;
&#125;</code></pre>
<p>现在我们学会了
<code>Splay操作</code>，那么其实也就很简单了，只需要像普通的二叉搜索树一样进行操作基本就行了，记住每次操作完后，将最后找到的点通过
<code>Splay操作</code> 转到根上去就可以了。</p>
<h3 id="插入-1">插入</h3>
<p>因为 <code>Splay</code>
本质上也是二叉搜索树，因此它满足二叉搜索树有的所有性质。<br />
插入方式和普通二叉搜索树一样，记住最后将插入的那个点旋转到根上即可~</p>
<p>代码如下：</p>
<pre class="cpp"><code>void insert(int x)&#123;
    if(root==0)&#123;
        val[++tot]=x;
        cnt[tot]++;
        pushup(tot);
        root=tot;
        return;
    &#125;
    int f=0,pos=root;
    while(true)&#123;
        if(val[pos]==x)&#123;
            cnt[pos]++;
            pushup(pos);
            pushup(f);
            Splay(pos,root);//记住Splay操作！！！
            return;
        &#125;
        f=pos;
        pos=son[pos][x&gt;val[pos]];
        if(pos==0)&#123;
            val[++tot]=x;
            cnt[tot]++;
            fa[tot]=f;
            son[f][x&gt;val[f]]=tot;
            pushup(tot);
            pushup(f);
            Splay(tot,root);//记住Splay操作！！！
            return;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="查询排名">查询排名</h3>
<p>设当前访问到的点是 <span class="math inline">\(pos\)</span>，答案为
<span class="math inline">\(ans\)</span>，最开始 <span
class="math inline">\(ans \gets 1\)</span>（因为排名至少为 <span
class="math inline">\(1\)</span>）。<br />
查询 <span class="math inline">\(x\)</span>
这个值的排名可以分为三种情况：</p>
<ol type="1">
<li><span class="math inline">\(x &gt; val_{pos}\)</span>：<br />
说明 <span class="math inline">\(pos\)</span> 这个点的左子树的所有值和
<span class="math inline">\(pos\)</span> 这个点的值都小于 <span
class="math inline">\(x\)</span><br />
那么排名至少为 <span
class="math inline">\(cnt_{son_{pos,0}}+cnt_{pos}\)</span><br />
即 <span class="math inline">\(ans \gets
ans+cnt_{son_{pos,0}}+cnt_{pos}\)</span><br />
然后继续到右子树中计算答案，即 <span class="math inline">\(pos \gets
son_{pos,1}\)</span><br />
</li>
<li><span class="math inline">\(x = val_{pos}\)</span>：<br />
说明 <span class="math inline">\(pos\)</span> 的左子树的所有值都小于
<span class="math inline">\(x\)</span><br />
并且 <span class="math inline">\(pos\)</span> 这个点的值刚好等于 <span
class="math inline">\(x\)</span><br />
因此排名就应该是 <span class="math inline">\(ans \gets
ans+siz_{son_{pos,0}}\)</span><br />
</li>
<li><span class="math inline">\(x &lt; val_{pos}\)</span>：<br />
说明 <span class="math inline">\(pos\)</span> 的左子树有比 <span
class="math inline">\(x\)</span> 大的值。<br />
因此此时不能对答案进行计算。<br />
需要继续到左子树中计算答案，即 <span class="math inline">\(pos \gets
son_{pos,1}\)</span></li>
</ol>
<pre class="cpp"><code>int selrank(int x)&#123;
    int res=0,pos=root;
    while(true)&#123;
        if(x==val[pos])&#123;
            Splay(pos,root);//将pos转到根后，其左子树就是答案，其实和前文表述是一样的
            return siz[pos[son][0]]+1;
        &#125;
        if(pos==0) break;
        if(x&lt;val[pos]) pos=son[pos][0];
        else&#123;
            res+=siz[son[pos][0]]+cnt[pos];
            pos=son[pos][1];
        &#125;
    &#125;
    return res+1;   
&#125;</code></pre>
<h3 id="查询排名对应的值">查询排名对应的值</h3>
<p>查询排名对应的值其实和查询值对应的排名很像。<br />
设当前访问到的点是 <span class="math inline">\(pos\)</span>，要找排名为
<span class="math inline">\(x\)</span> 的值。<br />
一样分为3种情况：</p>
<ol type="1">
<li><span class="math inline">\(x &gt;
siz_{son_{pos,0}}+cnt_{pos}\)</span>：<br />
说明答案在 <span class="math inline">\(pos\)</span> 的右子树中。<br />
因此将 <span class="math inline">\(x \gets
x-(siz_{son_{pos,0}}+cnt_{pos})\)</span><br />
再到右子树（<span class="math inline">\(pos \gets
son_{pos,1}\)</span>）中寻找答案即可。<br />
</li>
<li><span class="math inline">\(siz_{son_{pos,0}} &lt; x \le
siz_{son_{pos,0}}+cnt_{pos}\)</span>：<br />
说明答案就是 <span class="math inline">\(val_{pos}\)</span><br />
直接返回答案即可。<br />
</li>
<li><span class="math inline">\(x \le siz_{son_{pos,0}}\)</span>：<br />
说明答案在 <span class="math inline">\(pos\)</span> 的左子树。<br />
到左子树（<span class="math inline">\(pos \gets
son_{pos,0}\)</span>）中继续寻找答案即可。</li>
</ol>
<pre class="cpp"><code>//rt表示要在以哪个点为根的子树里寻找
int selval(int x,int &amp;rt)&#123;
    int pos=rt;
    while(true)&#123;
        if(x&lt;=siz[son[pos][0]]&amp;&amp;son[pos][0])&#123;
            pos=son[pos][0];
            continue;
        &#125;
        x-=siz[son[pos][0]]+cnt[pos];
        if(x&lt;=0)&#123;
            Splay(pos,rt);//记住Splay操作！！！
            return val[pos];
        &#125;
        pos=son[pos][1];
    &#125;
&#125;</code></pre>
<h3 id="查询前驱">查询前驱</h3>
<p>前驱被定义为比 <span class="math inline">\(x\)</span>
小的数中最大的数。<br />
因此我们只需要先将 <span class="math inline">\(x\)</span>
转到根上，再从根的左子树开始，一直跳右儿子即可。</p>
<pre class="cpp"><code>int selpre()&#123;
    int pos=son[root][0];
    while(son[pos][1]!=0) pos=son[pos][1];
    Splay(pos,root);//记住Splay操作！！！
    return pos;
&#125;</code></pre>
<p>注意：这个是找的是当前<strong>根所对应的值</strong>的前驱，如果需要查找任意一个数的前驱，可以先插入这个数，查完后再删除即可。</p>
<pre class="cpp"><code>int selpre_val(int x)&#123;
    int res;
    insert(x);
    res=val[selpre()];
    del(x);
    return res;
&#125;</code></pre>
<h3 id="查询后继">查询后继</h3>
<p>查找后继和前驱基本一致，只是开始从根的左儿子变成了右儿子，跳左儿子变成了跳右儿子。</p>
<pre class="cpp"><code>int selnext()&#123;
    int pos=son[root][1];
    while(son[pos][0]!=0) pos=son[pos][0];
    Splay(pos,root);//记住Splay操作！！！
    return pos;
&#125;</code></pre>
<p>查找任意一个数的后继和查找任意一个数的前驱是同样的道理：</p>
<pre class="cpp"><code>int selpre_val(int x)&#123;
    int res;
    insert(x);
    res=val[selnext()];
    del(x);
    return res;
&#125;</code></pre>
<h3 id="合并两颗splay树">合并两颗Splay树</h3>
<p>两颗 <code>Splay树</code>
想要快速合并，前提条件是一棵树的最大值小于另一棵树的最小值，否则无法做到快速合并。</p>
<p>合并分为三种情况:</p>
<ol type="1">
<li>两棵子树均为空，不用管。<br />
</li>
<li>一棵子树为空，直接把不为空的子树的根作为合并后的根即可。<br />
</li>
<li>两边子树均不为空，将第一棵子树的最大值转到根上，将左儿子设为另一颗树的根，<span
class="math inline">\(fa\)</span>
数组也跟着更新即可，最后合并出的根就是第一棵子树的根。</li>
</ol>
<p>为什么要将一棵树的最大值转到根后再合并？因为这样才能保证第一棵子树的右儿子是空的，才能够合并上去。</p>
<pre class="cpp"><code>int merge(int x,int y)&#123;//这里传的是两个树的根，返回值是合并后的根
    if(x==0||y==0) return x+y;
    int pos=x;
    while(son[pos][1]!=0) pos=son[pos][1];
    Splay(pos,root);//记住Splay操作！！！
    son[pos][1]=y;
    fa[y]=pos;
    pushup(pos);
    return pos;
&#125;</code></pre>
<h3 id="删除-1">删除</h3>
<p>删除操作相对比较复杂。<br />
因此放在最后面来讲 需要先将要删的这个点转到根上。<br />
如果这个点的 <span class="math inline">\(cnt\)</span> 值大于 <span
class="math inline">\(1\)</span>，那么直接将 <span
class="math inline">\(cnt_{pos} \gets  cnt_{pos}-1\)</span> 即可。
然后再找到这个点的前驱。<br />
将前驱作为新的根，合并两颗子树。</p>
<p>为什么要找前驱？<br />
因为在当前你要删除的这个点的右子树中，只有前驱可以<strong>保证</strong>没有右儿子。<br />
合并两棵子树也就是 <span class="math inline">\(O(1)\)</span> 的了。</p>
<pre class="cpp"><code>void del(int x)&#123;
    selrank(x);//这里的作用是将x转到根上
    if(cnt[root]&gt;1)&#123;
        cnt[root]--;
        pushup(root);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]==0)&#123;
        clear(root);
        root=0;
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]!=0)&#123;
        int past=root;
        root=son[root][1];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    if(son[root][0]!=0&amp;&amp;son[root][1]==0)&#123;
        int past=root;
        root=son[root][0];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    int past=root;
    int pos=selpre();//此时的pos已经成为根了，所以不用Splay操作了
    fa[son[past][1]]=pos;
    son[pos][1]=son[past][1];
    clear(past);
    pushup(root);
&#125;</code></pre>
<h3 id="代码-1">代码</h3>
<p>至此，你已经会了 Splay 的绝大多数操作了<br />
<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3369">板子</a>的代码也放在这里了~</p>
<p>ps：亲测本人 Splay 代码可以通过<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6136">加强版模板题</a></p>
<p>代码如下： <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <pre class="cpp"><code>// Problem: P3369 【模板】普通平衡树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3369
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x){
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
}
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y){
    read(x),read(y...);
}

int n,tot,root,cnt[MAXN],val[MAXN],fa[MAXN],son[MAXN][2],siz[MAXN];

int get(int x){return x==son[fa[x]][1];}
void pushup(int x){siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];}
void clear(int x){siz[x]=cnt[x]=val[x]=fa[x]=son[x][0]=son[x][1]=0;}

void rotate(int x){
    int y=fa[x],z=fa[y],ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    if(z) son[z][get(y)]=x;
    fa[y]=x;fa[x]=z;
    pushup(y);pushup(x);
}

void Splay(int x,int &amp;rt){
    int z=fa[rt];
    for(int f=fa[x];f!=z;f=fa[x]){
        if(fa[f]!=z) rotate(get(x)==get(f)?f:x);
        rotate(x);
    }
    rt=x;
}

void insert(int x){
    if(root==0){
        cnt[++tot]=1;
        siz[tot]=1;
        val[tot]=x;
        root=tot;
        return;
    }
    int f=0,pos=root;
    while(true){
        if(val[pos]==x){
            cnt[pos]++;
            pushup(pos);
            pushup(f);
            Splay(pos,root);
            return;
        }
        f=pos;
        pos=son[pos][x&gt;val[pos]];
        if(pos==0){
            cnt[++tot]++;
            val[tot]=x;
            fa[tot]=f;
            son[f][x&gt;val[f]]=tot;
            pushup(tot);
            pushup(f);
            Splay(tot,root);
            return;
        }
    }
}

int selrank(int x){
    int res=0,pos=root;
    while(true){
        if(val[pos]==x){
            Splay(pos,root);
            return siz[son[pos][0]]+1;
        }
        if(pos==0) break;
        if(val[pos]&lt;x){
            res+=siz[son[pos][0]]+cnt[pos];
            pos=son[pos][1];
        }
        else pos=son[pos][0];
    }
    return res+1;
}

int selval(int x,int &amp;rt){
    int pos=rt;
    while(true){
        if(x&lt;=siz[son[pos][0]]&amp;&amp;son[pos][0]){
            pos=son[pos][0];
            continue;
        }
        x-=siz[son[pos][0]]+cnt[pos];
        if(x&lt;=0){
            Splay(pos,rt);
            return val[pos];
        }
        pos=son[pos][1];
    }
}

int selpre(){
    int pos=son[root][0];
    while(son[pos][1]) pos=son[pos][1];
    Splay(pos,root);
    return pos;
}

int selnext(){
    int pos=son[root][1];
    while(son[pos][0]) pos=son[pos][0];
    Splay(pos,root);
    return pos;
}

void del(int x){
    selrank(x);
    if(cnt[root]&gt;1){
        cnt[root]--;
        pushup(root);
        return;
    }
    if(son[root][0]==0&amp;&amp;son[root][1]==0){
        clear(root);
        root=0;
        return;
    }
    if(son[root][0]!=0&amp;&amp;son[root][1]==0){
        int past=root;
        root=son[root][0];
        fa[root]=0;
        clear(past);
        return;
    }
    if(son[root][0]==0&amp;&amp;son[root][1]!=0){
        int past=root;
        root=son[root][1];
        fa[root]=0;
        clear(past);
        return;
    }
    int past=root;
    int pos=selpre();
    fa[son[past][1]]=pos;
    son[pos][1]=son[past][1];
    clear(past);
    pushup(root);
}

signed main(){
    read(n);
    for(int i=1;i&lt;=n;i++){
        int opt,z;
        read(opt,z);
        if(opt==1) insert(z);
        if(opt==2) del(z);
        if(opt==3) cout&lt;&lt;selrank(z)&lt;&lt;&#39;\n&#39;;
        if(opt==4) cout&lt;&lt;selval(z,root)&lt;&lt;&#39;\n&#39;;
        if(opt==5){insert(z);cout&lt;&lt;val[selpre()]&lt;&lt;&#39;\n&#39;;del(z);}
        if(opt==6){insert(z);cout&lt;&lt;val[selnext()]&lt;&lt;&#39;\n&#39;;del(z);}
    }
    return 0;
}</code></pre>

    </div>
</div></p>
<p>还没结束！</p>
<p>在平衡树的相关模板中，除了<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3369">【模板】普通平衡树</a>，<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6136">【模板】普通平衡树（数据加强版）</a>外，还有一道<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3391">【模板】文艺平衡树</a>。<del>（当然还有<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3835">【模板】可持久化平衡树</a>和<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5055">【模板】可持久化文艺平衡树</a>，但这个是
FHQ 干的事，我还不会。似乎还有一个神秘的<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6164">【模板】后缀平衡树</a>）</del></p>
<h3 id="文艺平衡树">文艺平衡树</h3>
<p>所谓文艺平衡树，其实是让你支持一种操作，区间翻转。<br />
这个操作看起来不太可做，实际上，我们可以利用二叉搜索树的性质来实现。</p>
<p>我们知道，二叉搜索树的<code>中序遍历</code>也就是原序列。<br />
我们为了实现<code>区间翻转</code>的操作，我们不妨修改一下，我们改成：</p>
<blockquote>
<p>中序遍历是原序列从左到右的遍历结果。</p>
</blockquote>
<p>那么我们又可以得到这些性质：</p>
<ul>
<li>Splay 上每一个元素代表了原序列的每一个元素。<br />
</li>
<li>Splay 上的每一棵子树都代表了原序列中一段的数。</li>
</ul>
<p>那么，在初始建树的时候，我们只需要按照序列原先的顺序，挨个挨个建一条只有左儿子的链就行了。</p>
<pre class="cpp"><code>void build(int n)&#123;
    for(int i=1;i&lt;=n+2;i++)&#123;
        son[++tot][0]=root;
        if(root!=0) fa[root]=tot;
        root=tot;
        val[tot]=i-1;
    &#125;
    Splay(1,root);//从下往上更新一下节点信息
&#125;</code></pre>
<p>那么我们怎么翻转呢？<br />
显然我们只需要将一棵子树的左右儿子挨个挨个调换位置就可以了。<br />
但如果我们直接每次翻转都去做一遍的话，时间复杂度显然会是 <span
class="math inline">\(O(n)\)</span> 的。我们考虑像线段树一样，记录一个
lazy 标签，需要下传的时候，再下传标记就可以了。</p>
<pre class="cpp"><code>void rev(int u)&#123;
    swap(son[u][0],son[u][1]);
    tag[u]^=1;
&#125;

void pushdown(int x)&#123;
    if(tag[x])&#123;
        if(son[x][0]) rev(son[x][0]);
        if(son[x][1]) rev(son[x][1]);
        tag[x]=0;
    &#125;
&#125;</code></pre>
<p>那我们怎么对区间 <span class="math inline">\([L,R]\)</span>
进行翻转呢？我们每次翻转是翻转一整棵子树，而一棵子树，又恰好对应了原序列的一段区间，因此我们只需要尝试将
<span class="math inline">\([L,R]\)</span>
区间弄到同一棵子树内就可以了。</p>
<p>根据中序遍历，一个结点的右子树对应的编号一定是比这个点对应的编号要大的。而左子树都是要更小的。<br />
所以我们不妨先把 <span class="math inline">\(L-1\)</span> 转到根上，再将
<span class="math inline">\(R+1\)</span> 转到 <span
class="math inline">\(L-1\)</span> 的右子树的根上。这样，<span
class="math inline">\(R+1\)</span> 的左子树对应的区间便是 <span
class="math inline">\([L,R]\)</span> 了。因为 <span
class="math inline">\(L\)</span> 可能为 <span
class="math inline">\(1\)</span>，<span class="math inline">\(R\)</span>
可能为 <span class="math inline">\(n\)</span>，此时 <span
class="math inline">\(L-1=0,R+1=n+1\)</span>
所以我们在初始建树的时候，便可以先在一前一后加上两个空节点。<br />
然后翻转的时候打个 lazy 标签，往下走的时候下传标签就好了。<br />
一定要记住，往下走的时候，就要下传一次标签！！！</p>
<pre class="cpp"><code>void reverse(int l,int r)&#123;
    selval(l,root);//因为初始序列前后各加了一个数，所以这里找第l个，刚好就是原序列的第l-1个
    selval((r+1)-(l-1),son[root][1]);
    int now=son[son[root[1]]][0];
    rev(now);
    pushdown(now);
    Splay(now,root);
&#125;</code></pre>
<p>其他部分和普通的平衡树差不多。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <pre class="cpp"><code>// Problem: P3391 【模板】文艺平衡树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3391
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x){
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
}
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y){
    read(x),read(y...);
}

int n,m,tot,root,val[MAXN],siz[MAXN],tag[MAXN],fa[MAXN],son[MAXN][2],cnt[MAXN];

int get(int x){return x==son[fa[x]][1];}
void pushup(int x){siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];}
void rev(int x){swap(son[x][0],son[x][1]);tag[x]^=1;}

void rotate(int x){
    int y=fa[x],z=fa[y],ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    if(z) son[z][get(y)]=x;
    fa[x]=z;fa[y]=x;
    pushup(y);pushup(x);
}

void Splay(int x,int &amp;rt){
    int z=fa[rt];
    for(int f=fa[x];f!=z;f=fa[x]){
        if(fa[f]!=z) rotate(get(x)==get(f)?f:x);
        rotate(x);
    }
    rt=x;
}

void build(int n){
    for(int i=0;i&lt;=n+1;i++){
        son[++tot][0]=root;
        if(root) fa[root]=tot;
        root=tot;
        val[tot]=i;
        cnt[tot]++;
    }
    Splay(1,root);
}

void pushdown(int x){
    if(tag[x]){
        if(son[x][0]) rev(son[x][0]);
        if(son[x][1]) rev(son[x][1]);
        tag[x]=0;
    }
}

int selval(int x,int &amp;rt){
    int pos=rt;
    while(true){
        pushdown(pos);
        if(x&lt;=siz[son[pos][0]]&amp;&amp;son[pos][0]) pos=son[pos][0];
        else{
            x-=siz[son[pos][0]]+cnt[pos];
            if(x&lt;=0){
                Splay(pos,rt);
                return val[pos];
            }
            pos=son[pos][1];
        }
    }
}

void reverse(int l,int r){
    selval(l,root);
    selval((r+1)-(l-1),son[root][1]);
    int x=son[son[root][1]][0];
    rev(x);
    pushdown(x);
    Splay(x,root);
}

void print(int x){
    if(!x) return;
    pushdown(x);
    print(son[x][0]);
    if(val[x]&gt;=1&amp;&amp;val[x]&lt;=n) cout&lt;&lt;val[x]&lt;&lt;&quot; &quot;;
    print(son[x][1]);
}

signed main(){
    read(n,m);
    build(n);
    for(int i=1;i&lt;=m;i++){
        int l,r;
        read(l,r);
        reverse(l,r);
    }
    print(root);
    return 0;
}</code></pre>

    </div>
</div>
<p>好，文艺平衡树到这里也就结束了！<br />
接下来，就正式进入 <code>LCT</code> 的部分了~</p>
<h2 id="lct">LCT</h2>
<p>现在，你应该已经掌握了所有的前置芝士，是时候真正进入LCT的部分了！！！</p>
<h3 id="讲解">讲解</h3>
<p>首先，我们称原来的树叫做<strong>原树</strong>。<br />
现在，我们为了实现删边和连边的操作，引入一棵新的树，叫做<strong>辅助树</strong>。<br />
注意！！！<strong>千万千万</strong>不要把这两棵弄混了！！！<br />
在下文中，我会将有关这两棵树的地方用不同的颜色标出。<br />
这是<span
class="math inline">\(\textcolor{green}{原树}\)</span>，这是<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>。</p>
<p>既然 LCT
又叫做<code>虚实链剖分</code>，那么肯定和一般的树剖有相似之处。<br />
我们定义有两种树边，一种是<code>实边</code>，一种是<code>虚边</code>，对应的连接的儿子也就分别是<code>实儿子</code>和<code>虚儿子</code>。<br />
<span
class="math inline">\(\textcolor{green}{原树}\)</span>中有儿子的节点一定有且仅有<strong>一条</strong><code>实边</code>（没有儿子当然也就没有<code>实边</code>），可以有任意多（包括
<span class="math inline">\(0\)</span>）条<code>虚边</code>。<br />
虚实链都是可以自由变换的，这个特点使得 LCT 可以实现 动态树
这一类问题。<br />
将由<code>实边</code>构成的树上的一条链称为<code>实链</code>。显然，每个点都会且仅会在<strong>一条</strong><code>实链</code>上。</p>
<p><span
class="math inline">\(\textcolor{green}{原树}\)</span>上的每一条实链，在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上对应的则是一棵
Splay。</p>
<p><span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>有如下性质：</p>
<ol type="1">
<li><span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上每个点与<span
class="math inline">\(\textcolor{green}{原树}\)</span>上的每个点一一对应。<br />
</li>
<li>对<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上每一棵 Splay
树进行<code>中序遍历</code>，得到的则是<span
class="math inline">\(\textcolor{green}{原树}\)</span>上这条对应的<code>实链</code><strong>从上到下</strong>的路径。<br />
</li>
<li><span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上每一棵 Splay
树的根节点是有父亲的。定义为<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上这棵 Splay
对应的<span
class="math inline">\(\textcolor{green}{原树}\)</span>上的那条<code>实链</code>的最顶端的节点的父亲。（特别的，最顶端的
Splay 的根节点是没有父亲节点的，或者说它的父亲节点是 <span
class="math inline">\(0\)</span>）<br />
</li>
<li>在 <span class="math inline">\(3\)</span>
中提到的<code>父亲关系</code>的特点是<strong>儿子认父亲，父亲不认儿子</strong>。而<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上的每一棵 Splay
内部的<code>父亲关系</code>则是<strong>儿子认父亲，父亲认儿子</strong>的。<br />
</li>
<li>在 LCT 上的所有操作，都只需要在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上操作即可，因为每一棵<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>都会对应<strong>唯一的</strong>一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>。</li>
</ol>
<p>假如我们有这样一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>：</p>
<p><img src="/images/LCT17.png" /></p>
<p>他的虚实链剖分可能长这样（因为虚实链很自由的原因，所以这并不是唯一一种剖分方式）：</p>
<p><img src="/images/LCT18.png" /></p>
<p>虚线边表示<code>虚边</code>，实线边表示<code>实边</code>。</p>
<p>那么根据定义，这棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>对应的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>可能就会是这样的：</p>
<p><img src="/images/LCT19.png" /></p>
<p>那么我们现在就需要思考，<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>是如何实现 动态树
这么一个难题的呢？</p>
<p>既然叫做 Link-Cut Tree，那么肯定就要 Link 和
Cut，下面我们来看看怎么连边。</p>
<h4 id="如何连边">如何连边</h4>
<p>拿这么两棵树举例：</p>
<p><img src="/images/LCT18.png" /> <img src="/images/LCT20.png" /></p>
<p>我们需要把 <span class="math inline">\(G\)</span> 和 <span
class="math inline">\(B\)</span> 连接起来，那么树就变成这个样子：</p>
<p><img src="/images/LCT21.png" /></p>
<p>我们发现蓝色边无论是<code>实边</code>，还是<code>虚边</code>，都是无法建出一棵合法的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的。因此我们要么在<span
class="math inline">\(\textcolor{green}{原树}\)</span>上作出修改，要么在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上做修改。<br />
根据前文所讲，我们只需要，也只能在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上做修改。<br />
那么我们怎么修改呢？</p>
<p>原先两棵树的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>可以是这样的：</p>
<p><img src="/images/LCT19.png" /></p>
<p><img src="/images/LCT22.png" /></p>
<p>那么假如直接连接 <span class="math inline">\(G\)</span> 和 <span
class="math inline">\(B\)</span> 就会是这样的：</p>
<p><img src="/images/LCT23.png" /></p>
<p>很显然的发现，这样是不合法的，因为 <span
class="math inline">\(G\)</span> 有了两个父亲。<br />
根据<span class="math inline">\(\textcolor{blue}{辅助树}\)</span>的性质
<span class="math inline">\(3\)</span>，我们知道，只有整棵<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的根节点才是没有父亲的。<br />
因此我们需要把 <span class="math inline">\(G\)</span>
点变成它所在的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的根的位置。<br />
我们定义一种新的函数叫做 <code>access(x)</code>，表示将 <code>x</code>
这个点与其当前变所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根结点弄到同一个
Splay 中。也就是将 <code>x</code>
到根的路径变成一条<code>实链</code>。<br />
那么在这个例子中，我们进行一次 <code>access(G)</code>，再
<code>Splay(G)</code> 一下，最后，连接 <span
class="math inline">\(G\)</span> 和 <span
class="math inline">\(B\)</span>，似乎就达成了任务，此时变为：</p>
<p><img src="/images/LCT24.png" /></p>
<p>但从<span
class="math inline">\(\textcolor{green}{原树}\)</span>的连接情况中我们可以看出：</p>
<p><img src="/images/LCT21.png" /></p>
<p>根据<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的性质 <span
class="math inline">\(2\)</span>，在这棵<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上，<span
class="math inline">\(I,G,H\)</span>
应该深度依次递增。但我们发现在连接后的<span
class="math inline">\(\textcolor{green}{原树}\)</span>上（假设以 <span
class="math inline">\(A\)</span>
点为根）并不满足这一点，因此目前的连接情况是不合法的。<br />
怎么处理这种情况？<br />
那么很显然的，我们让 <span class="math inline">\(G\)</span>
这个点变成它所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根就可以了。<br />
我们称这样将某个点变成其所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根的操作为
<code>makeroot(x)</code>，当然，我们依然只能在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上进行一些操作。<br />
那么这个 <code>makeroot(x)</code> 函数以及前文中的
<code>access(x)</code> 函数分别该怎样实现呢？</p>
<h4 id="access">access</h4>
<p>这里再用上文中的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的例子就不大好了。我们换一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-1.svg" /></p>
<p>（这里就直接搬了 OI-Wiki 上的原图了xwx）</p>
<p>（这里以 <span class="math inline">\(A\)</span> 点为<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根。）<br />
这棵<span class="math inline">\(\textcolor{green}{原树}\)</span>的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>可能长这样：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-2.svg" /></p>
<p>假如我们想要 <code>access(N)</code>。</p>
<p>也就是将<span
class="math inline">\(\textcolor{green}{原树}\)</span>变为这样：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-3.svg" /></p>
<p>（红色的边表示的是有虚实边类型切换的边）</p>
<p>首先我们肯定需要先将 <span class="math inline">\(N\)</span>
转到其所在的 Splay 的根处，这样我们才能继续往上嘛。<br />
根据 <code>access</code> 的定义，我们需要将原来 <span
class="math inline">\(N\)</span> 到 <span
class="math inline">\(O\)</span>
的<code>实边</code>变为<code>虚边</code>。<br />
根据<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>认父不认子的特点，我们可以直接将
<span class="math inline">\(N\)</span> 的儿子变成不存在。<br />
那么<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>就变成了这样：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-4.svg" /></p>
<p>然后，我们需要把 <span class="math inline">\(N\)</span> 与其在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上的父亲 <span
class="math inline">\(I\)</span> 打通。根据前面所讲，<span
class="math inline">\(I\)</span> 点也就是 <span
class="math inline">\(N\)</span> 目前所在的实链的顶端的点的父亲。<br />
那么我们要将 <span class="math inline">\(N\)</span> 与 <span
class="math inline">\(I\)</span> 打通，肯定需要先将 <span
class="math inline">\(I\)</span> 原来的实儿子取消掉。这个我们只需要先将
<span class="math inline">\(I\)</span> 点转到其所在的 Splay 的根处，然后
<span class="math inline">\(I\)</span> 原来的实儿子一定位于其在 Splay
上的<strong>右儿子</strong>处，直接将 <span
class="math inline">\(rson_{I}\)</span> 变成不存在就行了。<br />
然后，我们将 <span class="math inline">\(N\)</span> 设置为 <span
class="math inline">\(I\)</span> 的右儿子即可。<br />
那么<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>也就变成了这样：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-5.svg" /></p>
<p>重复上述操作，直到 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(N\)</span> 在同一棵 Splay 中。</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-6.svg" /></p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-7.svg" /></p>
<p>那么 <code>access(N)</code> 的任务就完成啦！</p>
<p>总结一下，<code>access</code> 操作也就是以下几步：</p>
<ol type="1">
<li>将当前点转到根上<br />
</li>
<li>将当前点的右儿子换成上一个点<br />
</li>
<li>更新一下当前点的信息<br />
</li>
<li>将当前点换成当前点的父亲</li>
</ol>
<p>代码如下：</p>
<pre class="cpp"><code>int access(int x)&#123;
    int now=0;
    for(;x;now=x,x=fa[x]) Splay(x),son[x][1]=now,pushup(x);
    pushup(x);
    return now;
&#125;</code></pre>
<p>注意到这里的 <code>access</code> 函数有一个返回值。<br />
这个返回值代表的是：最后一次进行虚实边变换的时候，虚边的父亲对应的编号。就比如在上面的例子中，最后一次变换的是
<span class="math inline">\(A\)</span> 到 <span
class="math inline">\(B\)</span> 这条边，这两条边的父亲节点都是 <span
class="math inline">\(A\)</span>，所以最后会返回 <span
class="math inline">\(A\)</span>。<br />
这个东西有什么用呢？我们后面再说。</p>
<h4 id="makeroot">makeroot</h4>
<p><code>makeroot</code> 的重要性不亚于
<code>access</code>，在前文我们已经讲解了为什么要使用
<code>makeroot</code>，以及 <code>makeroot</code>
的作用。现在我们直接来讲怎么做。</p>
<p>假设我们现在有这么一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>：</p>
<p><img src="\images\LCT25.png" /></p>
<p>虽然我们的<span
class="math inline">\(\textcolor{green}{原树}\)</span>是无向的，但是我们不妨假设其有向。（假设以
<span class="math inline">\(1\)</span> 号点为根）</p>
<p><img src="\images\LCT26.png" /></p>
<p>那我们发现，我们假如要让 <span class="math inline">\(4\)</span>
号点变成<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根，我们需要把树变成这样：</p>
<p><img src="\images\LCT27.png" /></p>
<p>我们发现，其实也就是将 <span class="math inline">\(1\)</span> 号点到
<span class="math inline">\(4\)</span> 号点的路径进行了翻转。<br />
那么也就是说，我们想要将某个点变成<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根，我们只需要将其到根节点的路径进行翻转就可以了。<br />
这个操作和 Splay 的翻转操作是类似的。</p>
<p>代码：</p>
<pre class="cpp"><code>void makeroot(int x)&#123;
    x=access(x);Splay(x);
    swap(son[x][0],son[x][1]);
    tag[x]^=1;
&#125;</code></pre>
<p>这里的 access 函数，将 <span class="math inline">\(u\)</span>
和当前的根放在了同一 Splay 下。但是我们又令 <span
class="math inline">\(u\gets
\operatorname{access}(u)\)</span>，这是为什么呢？<br />
我们前面在学习 Splay 的翻转操作时知道，Splay
的翻转操作是需要对一整棵子树操作的，而这里 <code>access(u)</code>
返回的值，恰好就是这棵 Splay 的根，为什么？看看 <code>access</code>
的代码，就明白了。</p>
<p>那我们现在，makeroot
函数也搞定了，终于可以连边了~直接按照前文所说的来操作就行了，注意先判一下要连的边是否在同一棵树中，如果在同一棵树中显然是不能连边的。</p>
<pre class="cpp"><code>void link(int x,int y)&#123;
    makeroot(x);Splay(x);
    if(findroot(y)!=x) fa[x]=y;
&#125;</code></pre>
<h4 id="如何删边">如何删边</h4>
<p>Link-Cut 中的 Link 我们解决了，那 Cut 呢？</p>
<p>我们现在要删掉 <span class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span>
之间的边，显然，我们需要判断这个操作是否合法，也就是 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 当前有没有边。这怎么去判断呢？<br />
当然你可以选择用 map 来存一下边。</p>
<p>首先，要有边，<span class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 必须得是联通的。也就是 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 在同一棵树内。<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的根会经常变化，而<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根只有在调用
<code>makeroot</code> 函数的时候才会发生变化，因此我们要知道 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 是否在同一棵子树中，只需要判断 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根是否是同一个点就行了。</p>
<p>怎么去找一个点所在<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根呢？我们稍后再讲。我们现在先把判断合法的条件讲完。</p>
<p><span class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span>
在同一棵树中显然并不能说明他们俩之间有边。而且我们只知道<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的形态。我们不妨先
<code>makeroot(x)</code>，这样的话，<span
class="math inline">\(y\)</span> 的就一定深于 <span
class="math inline">\(x\)</span> 了。我们令这个函数叫做
<code>findroot</code>。<br />
我们知道，LCT 将<span
class="math inline">\(\textcolor{green}{原树}\)</span>拆成了若干条链，那么如果
<span class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 在同一条实链上，至少可以说明它俩在<span
class="math inline">\(\textcolor{green}{原树}\)</span>上是可能相连的。<br />
另外，我们知道，一条虚边对应的两个点也显然之间是有边的（废话）。<br />
那么我们可以组合一下，如果 <span class="math inline">\(x\)</span> 和
<span class="math inline">\(y\)</span> 在<span
class="math inline">\(\textcolor{green}{原树}\)</span>上的路径上没有多的链，那么也有可能是合法的。那么我们此时先<code>Splay(y)</code>，这样的话，如果满足上面的条件，<span
class="math inline">\(y\)</span> 在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上的父亲绝对是
<span class="math inline">\(x\)</span>。<br />
当然这样依然不能判断是否有边。如果 <span
class="math inline">\(y\)</span> 在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上有左儿子，那么
<span class="math inline">\(y\)</span> 所在的实链中，存在在 <span
class="math inline">\(y\)</span> 之上，且不是 <span
class="math inline">\(x\)</span> 的点，那么这样的话，<span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间就存在其他边。</p>
<pre class="cpp"><code>void cut(int x,int y)&#123;
    makeroot(x);access(y);
    if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;!son[y][0]) son[x][1]=fa[y]=0;
&#125;</code></pre>
<p>那么我们就只剩下 <code>findroot</code> 这个函数了。</p>
<h4 id="findroot">findroot</h4>
<p>我们要找 <span class="math inline">\(x\)</span> 所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根，我们不妨先
<code>access(x)</code> 一下，再 <code>Splay(x)</code>
一下，这样的话，根就和 <span class="math inline">\(x\)</span> 在同一棵
Splay 中，并且根是这棵 Splay
中深度最小的那个点，直接一直跳左儿子即可。</p>
<pre class="cpp"><code>int findroot(int x)&#123;
    access(x);Splay(x);pushdown(x);
    while(son[x][0]) x=son[x][0],pushdown(x);
    Splay(x);
    return x;
&#125;</code></pre>
<p>那么我们 Cut 也就完成了！</p>
<h3 id="一些细节">一些细节</h3>
<p>最后还有一些细节。<br />
比如在 <code>Splay</code>，<code>rotate</code>
操作中，如果当前这个点是这棵 Splay
中的根了，显然不能继续向上了，因此我们需要判断一下一个点是否是其所在的点的根。</p>
<h4 id="isroot">isroot</h4>
<p>因为<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>认父不认子的特点，如果一个点既不是其父亲的左儿子，也不是右儿子，那么这个点就是这棵
Splay 的根。</p>
<pre class="cpp"><code>bool isroot(int x)&#123;return x!=son[fa[x]][0]&amp;&amp;x!=son[fa[x]][1];&#125;</code></pre>
<h4 id="update">update</h4>
<p>因为我们在进行 <code>Splay</code> 操作的时候，可能其上面的点还有 lazy
标签没有下传，这时如果直接 <code>Splay</code>
就会出问题，此时我们就先从上往下把标签下放即可。</p>
<pre class="cpp"><code>void update(int x)&#123;
    if(!isroot(x)) update(fa[x]);
    pushdown(x);
&#125;</code></pre>
<blockquote>
<p>为什么在文艺平衡树中不需要
update？因为在找到某个点的时候，其从根到这个点的路径上的标签均被下传过了，而这个点自己的标签又只会往下传，因此不会对
Splay 操作造成影响。</p>
</blockquote>
<h4 id="splay-rotate">Splay &amp; rotate</h4>
<p>那么再然后就是 <code>Splay</code> 函数和 <code>rotate</code>
函数的一点小改动了。</p>
<pre class="cpp"><code>void rotate(int x)&#123;
    int y=fa[x],z=fa[y],ch=get(x);
    if(!isroot(y)) son[z][get(y)]=x;
    //这一句要写在前面，因为我们要看y是否已经是根了，不然后面fa[y]改了后，y就一定不是根了。
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[x]=z;fa[y]=x;
    pushup(y);pushup(x);
&#125;

void Splay(int x)&#123;
    update(x);
    for(int f=fa[x];f&amp;&amp;!isroot(x);f=fa[x])&#123;
        if(!isroot(f)) rotate(get(x)==get(f)?f:x);
        rotate(x);
    &#125;
&#125;</code></pre>
<h3 id="提取路径信息">提取路径信息</h3>
<p>对于 LCT 的模板题而言，我们还需要维护路径信息，这个怎么实现呢？</p>
<p>我们现在需要维护 <span class="math inline">\(x\)</span> 到 <span
class="math inline">\(y\)</span> 的路径的一些关系，很自然可以想到先
<code>makeroot(x)</code>，再 <code>access(y)</code>。这样，<span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 就在同一条实链上了。我们不妨再
<code>Splay(y)</code>。这样，<span class="math inline">\(x\)</span> 到
<span class="math inline">\(y\)</span> 的路径就在 <span
class="math inline">\(y\)</span> 的子树中了，这个是很好维护的，我们在
<code>pushup</code> 的时候，顺带记录就好了。<br />
我们称这样提取出一条路径的操作叫做 <code>split</code>。</p>
<pre class="cpp"><code>void split(int x,int y)&#123;makeroot(x);access(y);Splay(y);&#125;</code></pre>
<p>对于模板题，我们维护异或和就行。</p>
<pre class="cpp"><code>void pushup(int x)&#123;xorsum[x]=xorsum[son[x][0]]^xorsum[son[x][1]]^val[x];&#125;</code></pre>
<h3 id="改变权值">改变权值</h3>
<p>改变权值是容易的，我们先把要改的位置 <code>Splay</code>
一下，再直接改就行了。这样是修改是没有影响的。</p>
<pre class="cpp"><code>void changeval(int x,int y)&#123;Splay(x);val[x]=y;&#125;</code></pre>
<p>那么，模板题就结束啦！</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <pre class="cpp"><code>// Problem: P3690 【模板】动态树（LCT）
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3690
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x){
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
}
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y){
    read(x),read(y...);
}

int n,m,tot,son[MAXN][2],fa[MAXN],tag[MAXN],xorsum[MAXN],val[MAXN];

int get(int x){return x==son[fa[x]][1];}
int isroot(int x){return x!=son[fa[x]][0]&amp;&amp;x!=son[fa[x]][1];}
void pushup(int x){xorsum[x]=xorsum[son[x][0]]^xorsum[son[x][1]]^val[x];}
void rev(int x){swap(son[x][0],son[x][1]);tag[x]^=1;}

void pushdown(int x){
    if(tag[x]){
        if(son[x][0]) rev(son[x][0]);
        if(son[x][1]) rev(son[x][1]);
        tag[x]=0;
    }
}

void update(int x){
    if(!isroot(x)) update(fa[x]);
    pushdown(x);
}

void rotate(int x){
    int y=fa[x],z=fa[y],ch=get(x);
    if(!isroot(y)) son[z][get(y)]=x;
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[x]=z;fa[y]=x;
    pushup(y);pushup(x);
}

void Splay(int x){
    update(x);
    for(int f=fa[x];f&amp;&amp;!isroot(x);f=fa[x]){
        if(!isroot(f)) rotate(get(x)==get(f)?f:x);
        rotate(x);
    }
}

int access(int x){
    int now=0;
    for(;x;now=x,x=fa[x]) Splay(x),son[x][1]=now,pushup(x);
    pushup(x);
    return now;
}

void makeroot(int x){
    x=access(x);Splay(x);
    swap(son[x][0],son[x][1]);
    tag[x]^=1;
}

int findroot(int x){
    access(x);Splay(x);pushdown(x);
    while(son[x][0]) x=son[x][0],pushdown(x);
    Splay(x);
    return x;
}

void link(int x,int y){
    makeroot(x);Splay(x);
    if(findroot(y)!=x) fa[x]=y;
}

void cut(int x,int y){
    makeroot(x);access(y);
    if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;!son[y][0]) son[x][1]=fa[y]=0;
}

void split(int x,int y){makeroot(x);access(y);Splay(y);}
int query(int x,int y){split(x,y);return xorsum[y];}
void changeval(int x,int y){Splay(x);val[x]=y;}

signed main(){
    read(n,m);
    for(int i=1;i&lt;=n;i++) read(val[i]);
    for(int i=1;i&lt;=m;i++){
        int opt,x,y;
        read(opt,x,y);
        if(opt==0) cout&lt;&lt;query(x,y)&lt;&lt;&#39;\n&#39;;
        if(opt==1) link(x,y);
        if(opt==2) cut(x,y);
        if(opt==3) changeval(x,y);
    }
    return 0;
}</code></pre>

    </div>
</div>
<h2 id="应用">应用</h2>
<p>我们知道，split 函数将<span
class="math inline">\(\textcolor{green}{原树}\)</span>上的一条路径提取出来了。那我们据此便可以实现很多东西。<br />
比如：维护路径点权和，最大值，最小值之类的。只要这种操作具有交换律和结合律，理论上来讲都是可以维护的。<br />
<del>所以一些LCT的题可以用轻重链剖分解决。</del></p>
<p>（此处暂时未写）</p>
<h3 id="维护连通性">维护连通性</h3>
<h3 id="维护-2-sat">维护 2-SAT</h3>
<p>在某些特殊的 2-SAT
中，我们连的是双向边，此时当然可以使用并查集来维护，但假如我们还需要删除，此时就可以使用
LCT。</p>
<h4 id="例题">例题</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7843">P7843
「C.E.L.U-03」布尔</a></p>
<p>此题题意很显然，给定区间 <span
class="math inline">\([l,r]\)</span>，求最少分割成几段，使得每段的限制条件均有解，输出最小段数。</p>
<p>我们首先来思考一下暴力怎么去做。<br />
有一个很显然的贪心：我们依次加边，如果出现不合法的情况，那么此时断开。这个显然是最优的。<br />
那么我们暴力就可以依次加边，然后跑一次 2-SAT
看是否合法，不合法就将答案加 <span
class="math inline">\(1\)</span>，然后将边清空，继续操作直到边用完。</p>
<p>这样的时间复杂度是 <span class="math inline">\(O(qn^2)\)</span>
的（设 <span class="math inline">\(n,m\)</span> 同阶）。可以获得 <span
class="math inline">\(10\)</span> 分。</p>
<p>这样显然是不可行的。我们发现，在这道题中，每次连的边均是双向边。于是我们并不需要使用
2-SAT 来每次暴力判断。我们使用并查集来维护，类似
2-SAT，我们将一个点拆成两个对立点，每次加边后合并一下并查集。如果存在某个点，其对立点处于同一并查集，则此时不合法。
（这种并查集也被称为“种类并查集”。）</p>
<p>此时的时间复杂度降为 <span
class="math inline">\(O(qn\alpha(n))\)</span>，可以获得 <span
class="math inline">\(40\)</span> 分。</p>
<p>如果想要通过，显然不可以每次询问都暴力去做。<br />
我们发现，对于一个位置 <span
class="math inline">\(pos\)</span>，假设其合法的最远位置为 <span
class="math inline">\(a\)</span>，那么 <span
class="math inline">\(\forall b\in [pos,a]\)</span>，区间 <span
class="math inline">\([pos,b]\)</span> 均是合法的。<br />
于是我们记 <span class="math inline">\(f(i)\)</span> 表示 <span
class="math inline">\(i\)</span>
这个位置合法的最远位置的后一个位置。注意，是后一个位置（虽然不是后一个位置也不是不行）！发现这个东西是可以倍增的！<br />
于是我们现在便可以每次先暴力地求出每个位置的 <span
class="math inline">\(f\)</span> 地值，然后使用倍增来快速回答。</p>
<p>假设我们依然使用并查集来判断合法情况，此时的时间复杂度为 <span
class="math inline">\(O(n^2\alpha(n)+q\log n)\)</span>，似乎也许可以得到
<span class="math inline">\(70pts\)</span>。</p>
<p>询问的速度已经足够了，我们考虑优化预处理部分。</p>
<p>容易发现，对于 <span class="math inline">\(f(i)\)</span> 和 <span
class="math inline">\(f(i+1)\)</span>，是存在大量交集的，我们每次暴力去做，显然不优。于是便可以想到使用双指针去扫描。<br />
但是我们的并查集是不允许删除操作的。什么东西又可以连边又可以删边呢？LCT
可以。于是我们现在就来仔细想想 LCT 怎么去实现这个预处理。</p>
<p>我们令当前的区间为 <span
class="math inline">\([l,r]\)</span>，我们此时需要将 <span
class="math inline">\(r\)</span> 进行扩展，需要连接 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 两个点。我们分两种情况来讨论。</p>
<ol type="1">
<li>连接 <span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 后没有出现环，那么直接连接即可。<br />
</li>
<li>连接 <span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span>
后出现了环，理论上来说我们随便断开一条边，是不会影响到连通性的，但是我们后面可能需要将
<span class="math inline">\(l\)</span> 往前挪，此时需要删除编号为 <span
class="math inline">\(l\)</span>
的边。如果我们前面随意删除了一条边，此时又删去了 <span
class="math inline">\(l\)</span>
这条边，可能导致原本应该连通的图变得不连通。那么我们就删去编号最小的边，这样就没有影响了。</li>
</ol>
<p>将 <span class="math inline">\(r\)</span>
扩展后，我们此时需要判断是否合法，从而决定 <span
class="math inline">\(l\)</span> 点是否需要往前挪。<br />
我们不可能 <span class="math inline">\(O(n)\)</span>
的去遍历每个点看是否合法，这样的时间复杂度是 <span
class="math inline">\(O(n\log n)\)</span> 的，还不如并查集。<br />
但是我们又发现连接了一条边后，出现冲突的位置是不确定的。<br />
思考一下，发现我们将前面连接的边，对于其对立点，我们也连边，假如没有出现冲突，这两部分会是独立的。而假如出现冲突，则一定是因为这条边的假如而冲突，那么也就是连接的这条边的两端点出现了冲突。这样我们只需要判断一次即可知道是否出现冲突。</p>
<p>那么基本也就结束了，时间复杂度 <span class="math inline">\(O(n\log
n+q\log n)\)</span>，常数较大，但是是可以通过的。<br />
细节有点多，具体可以看代码。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <pre class="cpp"><code>// Problem: P7843 「C.E.L.U-03」布尔
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7843
// Memory Limit: 256 MB
// Time Limit: 2500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1.5e6+10;
const int mod1=1e9+7;
const int mod2=998244353;
const int inf_int=0x7f7f7f7f;
const long long inf_long=0x7f7f7f7f7f7f7f7f;
const double eps=1e-9;
char Buf[1&lt;&lt;23],*P1=Buf,*P2=Buf;
#define getchar() (P1==P2&amp;&amp;(P2=(P1=Buf)+fread(Buf,1,1&lt;&lt;23,stdin),P1==P2)?EOF:*P1++)
template&lt;typename type&gt;
inline void read(type &amp;x){
    x=0;
    bool f=false;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) f|=ch==&#39;-&#39;,ch=getchar();
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+(ch^48),ch=getchar();
    if(f) x=-x;
}
template&lt;typename type,typename... args&gt;
inline void read(type &amp;x,args&amp;... y){
    read(x),read(y...);
}

bool awa;
int n,m,q,l,r,cnt,e_cnt,tag[MAXN],fa[MAXN],son[MAXN][2],val[MAXN],minval[MAXN],f[MAXN][21];
int U[MAXN],X[MAXN],V[MAXN],Y[MAXN];

bool get(int x){return x==son[fa[x]][1];}
bool isroot(int x){return x!=son[fa[x]][0]&amp;&amp;x!=son[fa[x]][1];}
void rev(int x){swap(son[x][0],son[x][1]);tag[x]^=1;}
void pushup(int x){minval[x]=min({val[x],minval[son[x][0]],minval[son[x][1]]});}

void pushdown(int x){
    if(tag[x]){
        if(son[x][0]) rev(son[x][0]);
        if(son[x][1]) rev(son[x][1]);
        tag[x]=0;
    }
}

void update(int x){
    if(!isroot(x)) update(fa[x]);
    pushdown(x);
}

void rotate(int x){
    int y=fa[x],z=fa[y],ch=get(x);
    if(!isroot(y)) son[z][get(y)]=x;
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[y]=x;fa[x]=z;
    pushup(y);pushup(x);
}

void Splay(int x){
    update(x);
    for(int f=fa[x];!isroot(x);f=fa[x]){
        if(!isroot(f)) rotate(get(x)==get(f)?f:x);
        rotate(x);
    }
}

int access(int x){
    int pos=0;
    for(;x;pos=x,x=fa[x]) Splay(x),son[x][1]=pos,pushup(x);
    pushup(x);
    return pos;
}

void makeroot(int x){x=access(x);Splay(x);rev(x);}

int findroot(int x){
    access(x);Splay(x);pushdown(x);
    while(son[x][0]) x=son[x][0],pushdown(x);
    Splay(x);return x;
}

void link(int x,int y){
    makeroot(x);Splay(x);
    if(findroot(y)!=x) fa[x]=y;
}

void cut(int x,int y){
    makeroot(x);access(y);
    if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;!son[y][0]) fa[y]=son[x][1]=0;
}

void split(int x,int y){makeroot(x);access(y);Splay(y);}
void change(int pos,int z){Splay(pos);val[pos]=z;pushup(pos);}

void get(int &amp;x1,int &amp;y1,int &amp;x2,int &amp;y2,int &amp;id1,int &amp;id2,int i){
    id1=i+2*n;id2=i+2*n+m;
    if(X[i]^Y[i]) x1=U[i],y1=V[i]+n,x2=U[i]+n,y2=V[i];
    else x1=U[i],y1=V[i],x2=U[i]+n,y2=V[i]+n;
}

bool t(int x,int y){
    return findroot(x)==findroot(y);
}
bool qwq;

signed main(){
    // cout&lt;&lt;(&amp;awa-&amp;qwq)/1024.0/1024.0&lt;&lt;endl;
    read(n,m,q);cnt=n;
    for(int i=0;i&lt;=2*n+2*m;i++) val[i]=minval[i]=1e9;
    l=r=1;
    for(int i=1;i&lt;=m;i++,r++){
        read(U[i],X[i],V[i],Y[i]);
        int x1,x2,y1,y2,id1,id2;
        get(x1,y1,x2,y2,id1,id2,i);
        if(t(x1,y1)){
            split(x1,y1);
            int minedge=minval[y1];
            int xx,yy,XX,YY,ID1,ID2;
            get(xx,yy,XX,YY,ID1,ID2,minedge);
            cut(xx,ID1);cut(ID1,yy);
            cut(XX,ID2);cut(ID2,YY);
        }
        change(id1,i);
        link(x1,id1);link(id1,y1);
        while(t(x1,x2)){
            f[l][0]=r;
            int xx,yy,XX,YY,ID1,ID2;
            get(xx,yy,XX,YY,ID1,ID2,l);
            cut(xx,ID1);cut(ID1,yy);
            cut(XX,ID2);cut(ID2,YY);
            l++;
        }
        change(id2,i);
        link(x2,id2);link(id2,y2);
    }
    for(;l&lt;=m;l++) f[l][0]=m+1;
    for(int i=m;i&gt;=1;i--) for(int j=1;j&lt;21;j++) f[i][j]=f[f[i][j-1]][j-1];
    for(int i=1;i&lt;=q;i++){
        int l,r,ans=0;
        read(l,r);
        for(int j=20;j&gt;=0;j--){
            if(f[l][j]&gt;0&amp;&amp;f[l][j]&lt;=r+1){
                ans+=(1&lt;&lt;j);
                l=f[l][j];
            }
        }
        if(l!=r+1){
            for(int j=0;j&lt;=20;j++){
                if(f[l][j]&gt;=r+1){
                    ans+=(1&lt;&lt;j);
                    break;
                }
            }
        }
        if(f[l][0]==l){
            cout&lt;&lt;-1&lt;&lt;&#39;\n&#39;;
            continue;
        }
        cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
    }
    return 0;
}</code></pre>

    </div>
</div>
<h3 id="维护-sam">维护 SAM</h3>
<p>前置知识：SAM，LCT 维护连通性</p>
<h4 id="例题-1">例题</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6292">P6292
区间本质不同子串个数</a></p>
<p>题意很简单，多次询问，每次询问区间 <span
class="math inline">\([l,r]\)</span> 的本质不同子串个数。</p>
<p>首先我们想一想假如问的是整个串的本质不同子串数量应该怎么做。这个是一个
SAM 的简单运用。<br />
见：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2408">P2408
不同子串个数</a><br />
对于这个问题，我们建出 SAM 后，对于每一个节点，其代表的子串长度为 <span
class="math inline">\(len_{fa_{i}}+1\)</span> 到 <span
class="math inline">\(len_{i}\)</span>，于是减一下，就得到答案了。</p>
<p>那么对于这道题而言，我们不可能每次询问都重新建一次
SAM，然后统计答案，这样的时间复杂度是 <span
class="math inline">\(O(qn)\)</span> 的，显然无法通过。</p>
<p>我们先来看这么一道经典题：给定一个序列 <span
class="math inline">\(a\)</span>
，多次询问，每次询问一段区间内本质不同的数的数量。<br />
这道题的做法是这样的： 先将所有询问离线下来，按照 <span
class="math inline">\(r\)</span>
为关键字排序，然后进行扫描线，对每一个位置 <span
class="math inline">\(r\)</span> 维护 <span
class="math inline">\(l\in[1,r]\)</span> 的答案，当我们新加入一个 <span
class="math inline">\(a_{r}\)</span> 时，我们将这个位置的 <span
class="math inline">\(val_{r}\)</span> 增加 <span
class="math inline">\(1\)</span>，然后对于上一个值同样为 <span
class="math inline">\(a_{r}\)</span> 的位置 <span
class="math inline">\(last_{a_{r}}\)</span> 的 <span
class="math inline">\(val_{last_{a_{r}}}\)</span> 减少 <span
class="math inline">\(1\)</span>。那么对于一个区间 <span
class="math inline">\([l,r]\)</span>，其的答案就是 <span
class="math inline">\(\sum_{i=l}^{r} val_{i}\)</span>。</p>
<p>我们将这个问题延伸到字符串上，对于一个子串 <span
class="math inline">\(S\)</span>，它对应的是原串 <span
class="math inline">\(A\)</span> 的 <span
class="math inline">\([l,r]\)</span> 区间，那么当询问 <span
class="math inline">\([L,R]\)</span> 满足 <span
class="math inline">\(R\ge r,L\le l\)</span> 时，则会产生 <span
class="math inline">\(1\)</span> 的贡献。而我们现在出现了另外一个子串
<span class="math inline">\(S&#39;=S\)</span>，它对应的区间是 <span
class="math inline">\([L&#39;,R&#39;]\)</span>，那么我们按照上道题的思路，</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2025 yzljyのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yzljy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="yzljyawa/yzljyawa.github.io"
    data-repo-id="R_kgDOMbAUfA"
    data-category="Announcements"
    data-category-id="DIC_kwDOMbAUfM4CiQYe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
