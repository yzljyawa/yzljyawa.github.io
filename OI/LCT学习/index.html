
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>LCT学习笔记 | yzljyのBlog</title>
    <meta name="author" content="yzljy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/yzljy.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YZLJYのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YZLJYのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>LCT学习笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/1
        </span>
        
        <span class="category">
            <a href="/categories/OI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                OI
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #a5ff4d">
                    数据结构
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" style="color: #e74c3c">
                    学习指南
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/LCT/" style="color: #979a9a">
                    LCT
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="color: #00beff">
                    树链剖分
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="color: #979a9a">
                    平衡树
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="是什么">是什么</h1>
<p>Link-Cut-Tree<br />
一般称作
<code>LCT</code>/<code>动态树</code>/<code>虚实链剖分</code><br />
由著名巨佬 Tarjan 发明（对，又是他）
用于解决动态的树上路径/子树问题（统称为<strong>动态树</strong>问题）<br />
对于普通的树上问题，比如：</p>
<blockquote>
<p>给定一颗 <span class="math inline">\(n\)</span>
个节点的树，每个节点均有权值，需要维护三个操作：<br />
1.查询 <span class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 路径上的权值和<br />
2.查询以 <span class="math inline">\(u\)</span> 为根的子树的权值和<br />
3.将 <span class="math inline">\(u\)</span> 点的权值修改为 <span
class="math inline">\(val\)</span></p>
</blockquote>
<p>那么这是一道很板的 <del>熟练剖粪</del> 树链剖分题<br />
但假如我们还需要维护两个操作：</p>
<blockquote>
<p>4.将 <span class="math inline">\(u,v\)</span>
这条边断开（如果有边的话）<br />
5.将 <span class="math inline">\(u,v\)</span> 连接起来（若 <span
class="math inline">\(u,v\)</span> 不在同一连通块内）</p>
</blockquote>
<p>那么现在，普通的树剖就没有办法解决了<br />
这时候，我们就需要用到 LCT</p>
<h1 id="怎么做">怎么做</h1>
<p><strong>变量声明</strong></p>
<blockquote>
<p><span class="math inline">\(root\)</span> 表示树的根<br />
<span class="math inline">\(tot\)</span> 表示当前树的节点个数<br />
<span class="math inline">\(val[i]\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的权值<br />
<span class="math inline">\(son[i][0]\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的左儿子<br />
<span class="math inline">\(son[i][1]\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的右儿子<br />
<span class="math inline">\(fa[i]\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的父亲<br />
<span class="math inline">\(tag[i]\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的翻转标记<br />
<span class="math inline">\(cnt[i]\)</span> 表示 <span
class="math inline">\(i\)</span>
节点存储的数量（同样的值放在同一个节点）<br />
<span class="math inline">\(siz[i]\)</span> 表示以 <span
class="math inline">\(i\)</span> 节点为根的子树大小</p>
</blockquote>
<p>先将 LCT 模板题放在 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3690">这里</a><br />
其实 LCT 的码量并不算太大，但是就比较难理解</p>
<p>前置芝士：<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</a>
<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#splay">Splay</a><br />
<del>哪里不会点哪里</del><br />
<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#lct">跳过</a></p>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%80%8E%E4%B9%88%E5%81%9A">返回</a></p>
<p>我们在对一个序列进行各种操作的时候<br />
可能会遇见让你插入某个数，删除某个数，还需要让你随时都保证有序<br />
假如我们对一个普通的数组这样操作的话，如果从中间插入和删除之类的，需要用到
<span class="math inline">\(O(n)\)</span> 的时间来维护序列的有序<br />
这样显然无法接受，我们需要优化时间复杂度<br />
考虑将序列转移到一颗二叉树上</p>
<h3 id="输出">输出</h3>
<p>我们让二叉树的中序遍历的结果，就是原先的序列</p>
<p>那么怎么维护有序？假设我们需要维护单调递增的序列，对于每个节点 <span
class="math inline">\(i\)</span> 都满足 <span
class="math inline">\(val[son[i][0]] &lt; val[i] &lt;
val[son[i][1]]\)</span> 即可</p>
<p>这样的话，经过中序遍历后得到的结果，就是单调递增的原序列了</p>
<h3 id="插入">插入</h3>
<p>设插入的值为 <span class="math inline">\(v\)</span><br />
根据前面所讲的输出方式，我们在插入的时候，使二叉树依然满足性质即可。
最开始令 <span class="math inline">\(pos \gets root\)</span> （ps：<span
class="math inline">\(a \gets b\)</span> 表示将 <span
class="math inline">\(b\)</span> 的值赋给 <span
class="math inline">\(a\)</span>）<br />
一直重复下面这个式子，直到 <span
class="math inline">\(pos=0\)</span></p>
<p><span class="math display">\[
\left\{\begin{matrix}
  pos \gets son[pos][0](v&lt;val[pos])\\
  pos \gets son[pos][1](v&gt;val[pos])
\end{matrix}\right.
\]</span></p>
<p><span class="math inline">\(pos=0\)</span> 后，我们就可以将 <span
class="math inline">\(tot \gets tot+1\)</span> 并将新的这个权值 <span
class="math inline">\(v\)</span> 赋给 <span
class="math inline">\(val[tot]\)</span><br />
记住插入后要更新 <span class="math inline">\(fa[tot]\)</span> 和 <span
class="math inline">\(son[fa[tot]][0/1]\)</span>
这样插入操作就完成了！<br />
代码如下：</p>
<pre class="cpp"><code>void insert(int v)&#123;
    int pos=root;
    int f=0;
    while(true)&#123;
        if(pos==0)&#123;
            val[++tot]=v;
            fa[tot]=f;
            if(f!=0) son[f][v&gt;val[f]]=v;
            break;
        &#125;
        fa=pos;
        if(v==val[pos])&#123;
            cnt[pos]++;
            break;
        &#125;
        pos=son[pos][v&gt;val[pos]];
    &#125;
&#125;</code></pre>
<h3 id="查找某个值所在的位置">查找某个值所在的位置</h3>
<p>设需要查找的值为 <span class="math inline">\(v\)</span>（保证 <span
class="math inline">\(v\)</span> 存在）<br />
那么就和插入操作很类似了，只是我们当 <span
class="math inline">\(v=val[pos]\)</span> 的时候，直接返回 <span
class="math inline">\(pos\)</span> 即可<br />
代码如下：</p>
<pre class="cpp"><code>int selpos(int v)&#123;
    int pos=root;
    while(true)&#123;
        if(val[pos]==v) return pos;
        pos=son[pos][v&gt;val[pos]];
    &#125;
&#125;</code></pre>
<h3 id="删除">删除</h3>
<p>设需要删除的值为 <span class="math inline">\(v\)</span><br />
删除操作需要先找到 <span class="math inline">\(v\)</span>
的位置，删除后，合并他的左右两颗子树即可<br />
代码如下：</p>
<pre class="cpp"><code>void clear(int pos)&#123;
    val[pos]=son[pos][0]=son[pos][1]=fa[pos]=0;
&#125;//清空节点pos
void del(int v)&#123;
    int pos=selpos(v);
    if(son[pos][0]==0&amp;&amp;son[pos][1]==0)&#123;
        clear(pos);
        return;
    &#125;
    if(son[pos][0]==0&amp;&amp;son[pos][1]!=0)&#123;
        fa[son[pos][1]]=fa[pos];
        if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][1];
        clear(pos);
        return;
    &#125;
    if(son[pos][0]!=0&amp;&amp;son[pos][1]==0)&#123;
        fa[son[pos][0]]=fa[pos];
        if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][0];
        clear(pos);
        return;
    &#125;
    fa[son[pos][0]]=son[pos][1];
    fa[son[pos][1]]=fa[pos];
    if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][1];
    clear(pos);
&#125;</code></pre>
<h3 id="更多操作">更多操作</h3>
<ul>
<li>查询 <span class="math inline">\(v\)</span> 这个值的排名<br />
</li>
<li>查询 <span class="math inline">\(x\)</span> 这个排名的值<br />
</li>
<li>查询 <span class="math inline">\(v\)</span> 这个值的前驱<br />
</li>
<li>查询 <span class="math inline">\(v\)</span> 这个值的后继</li>
</ul>
<p>请读者自行尝试或者查阅，因为普通的二叉搜索树容易被卡，因此在后文讲解
<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C-1">Splay的更多操作</a>
时具体讲解</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>空间复杂度：<br />
我们每次在插入时只会多一个，因此空间复杂度为 <span
class="math inline">\(O(n)\)</span></p>
<p>时间复杂度：<br />
理想情况下， <span class="math inline">\(n\)</span>
个数据构成的二叉树的高度为 <span class="math inline">\(\log{n}\)</span>
因此在插入删除时均最多跳 <span class="math inline">\(\log{n}\)</span>
次，最优时间复杂度为 <span
class="math inline">\(O(\log{n})\)</span><br />
但是我们可以通过构造如 <code>1 2 3 4 5</code>
这样单调的数据，来使树高变为 <span
class="math inline">\(O(n)\)</span>，此时二叉搜索树退化为<strong>链</strong>，插入和删除时最多会跳
<span class="math inline">\(n\)</span> 次，最劣时间复杂度为 <span
class="math inline">\(O(n)\)</span></p>
<p>总之，普通的二叉搜索树没法保证时间复杂度，我们需要优化</p>
<h2 id="splay">Splay</h2>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%80%8E%E4%B9%88%E5%81%9A">返回</a></p>
<p>Splay 是一种自平衡的 <a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</a><br />
（ps：关于更多平衡树，以后会讲）</p>
<p>Splay 通过一种叫做 <code>Splay</code>
的操作，防止二叉搜索树退化为链，保证了树高为 <span
class="math inline">\(O(\log{n})\)</span> 级别，保证了各个操作的 <span
class="math inline">\(O(\log{n})\)</span> 时间复杂度</p>
<h3 id="基础操作">基础操作</h3>
<p>直接上代码吧：</p>
<pre class="cpp"><code>void clear(int x)&#123;
    fa[x]=val[x]=son[x][0]=son[x][1]=cnt[x]=siz[x]=0;
&#125;//清空x节点
void pushup(int x)&#123;
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];
&#125;//更新x节点的子树大小
bool get(int x)&#123;
    return x==son[fa[x]][1];
&#125;//得到点x属于fa[x]的左儿子还是右儿子</code></pre>
<h3 id="旋转操作">旋转操作</h3>
<p>若你学过 Treap 之类的带旋平衡树，这一部分可以选择<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#splay%E6%93%8D%E4%BD%9C">略过</a>（建议不要略过）</p>
<p>由中序遍历的性质：同一种中序遍历对应的二叉树不止一颗<br />
我们可以通过一些操作，在保证中序遍历不变的前提下，来使树高变低<br />
这种操作就称作 <code>旋转操作</code>，一般函数名为
<code>rotate</code></p>
<p>为什么要旋转从下文开看<br />
旋转部分讲解<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%97%8B%E8%BD%AC%E8%BF%87%E7%A8%8B%E8%AE%B2%E8%A7%A3">点这里</a><br />
直接看代码<a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E4%BB%A3%E7%A0%81">点这里</a></p>
<h4 id="为什么要旋转">为什么要旋转</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C">返回</a></p>
<p>对于这么一棵二叉树</p>
<p><img src="/images/LCT1.png" /></p>
<p>我们要将其转成这样：</p>
<p><img src="/images/LCT2.png" /></p>
<p>当然也可以转回来<br />
这样进行一次旋转后，x的高度提高了一层<br />
看似对总的高度没有影响<br />
但对于这样的退化成链的情况时：</p>
<p><img src="/images/LCT3.png" /></p>
<p>我们可以通过如下操作，将高度降低</p>
<p>1.对点 <span class="math inline">\(1\)</span> 进行旋转操作<br />
会变成这样：</p>
<p><img src="/images/LCT4.png" /></p>
<p>2.再对点 <span class="math inline">\(1\)</span> 进行旋转操作<br />
会变成这样：</p>
<p><img src="/images/LCT5.png" /></p>
<p>3.继续对点 <span class="math inline">\(1\)</span> 进行旋转操作
会变成这样：</p>
<p><img src="/images/LCT6.png" /></p>
<p>4.最后对点 <span class="math inline">\(3\)</span> 进行旋转操作
会变成这样：</p>
<p><img src="/images/LCT7.png" /></p>
<p>至此，我们成功地通过旋转操作将高度从 <span
class="math inline">\(4\)</span> 降到 <span
class="math inline">\(3\)</span><br />
因此旋转操作是必须的</p>
<h4 id="旋转过程讲解">旋转过程讲解</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C">返回</a></p>
<p>我们令要进行 <code>rotate</code> 操作的点为 <span
class="math inline">\(x\)</span><br />
令:<br />
<span class="math inline">\(y \gets fa[x]\)</span><br />
<span class="math inline">\(z \gets fa[y]\)</span><br />
<span class="math inline">\(ch \gets get(x)\)</span></p>
<p>根据这两个图：</p>
<p><img src="/images/LCT1.png" /></p>
<p><img src="/images/LCT2.png" /></p>
<p>我们可以发现：<br />
（ps：<span class="math inline">\(a \oplus b\)</span> 表示 "<span
class="math inline">\(a\)</span> 异或 <span
class="math inline">\(b\)</span>"）<br />
（此时的 <span class="math inline">\(ch=0\)</span>）</p>
<ul>
<li><span class="math inline">\(son[x][ch]\)</span> 没有发生变化<br />
</li>
<li><span class="math inline">\(son[x][ch \oplus 1]\)</span> 变成了
<span class="math inline">\(y\)</span><br />
</li>
<li><span class="math inline">\(son[y][ch]\)</span> 从 <span
class="math inline">\(x\)</span> 变成了 <span
class="math inline">\(son[x][ch \oplus 1]\)</span><br />
</li>
<li>对应的 <span class="math inline">\(fa\)</span>
的的值也会随之变化</li>
</ul>
<p>最后再处理一下先后执行顺序，就可以写出旋转操作的代码啦~</p>
<h4 id="代码">代码</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C">返回</a></p>
<pre class="cpp"><code>void rotate(int x)&#123;
    int y=fa[x],z=fa[y];bool ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]!=0) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[y]=x;
    fa[x]=z;
    if(z!=0) son[z][y==son[z][1]]=x;
    pushup(y);
    pushup(x);
&#125;</code></pre>
<h3 id="splay操作">Splay操作</h3>
<p>Splay 规定，每次操作后，都要将操作的点转到根上，这样的操作就被称为
<code>Splay操作</code></p>
<p>怎么转移到根上？暴力一次次往上旋转即可</p>
<h4 id="单旋splay">单旋Splay</h4>
<p>如果只是像上文那样旋转，也就是从下往上一次转，这样的被称为
<code>单旋Splay</code><br />
当出现 <span class="math inline">\(x,y,z\)</span>
三点共线时，我们发现，依此转完后，树高是没有变化的，这样就没法保证时间复杂度（见下面几张图理解）</p>
<p><img src="/images/LCT8.png" /></p>
<p>我们需要将 <span class="math inline">\(1\)</span> 号点转到根去</p>
<p>那么我们只需要旋转四次 <span class="math inline">\(1\)</span>
号点就可以了<br />
转的过程如下：</p>
<p><img src="/images/LCT9.png" /></p>
<p><img src="/images/LCT10.png" /></p>
<p><img src="/images/LCT11.png" /></p>
<p><img src="/images/LCT12.png" /></p>
<p>这样的话，就是“如转”<br />
我们虽然将 <span class="math inline">\(1\)</span>
号点转到了根上，但是高度并没有降低<br />
因此当树退化为一条链的时候<br />
<code>单旋Splay</code> 也就没法保证时间复杂度了</p>
<p>这时候我们就需要用到 <code>双旋Splay</code></p>
<h4 id="双旋splay">双旋Splay</h4>
<p><code>双旋Splay</code> 其实就是在 <code>单旋Splay</code>
的基础上，特殊处理了一下 <span class="math inline">\(u,v,z\)</span>
三点共线的情况<br />
在遇到三点共线的情况时，我们只需要先旋转 <span
class="math inline">\(fa[u]\)</span> 也就是 <span
class="math inline">\(v\)</span> 点，再旋转一次 <span
class="math inline">\(u\)</span> 点即可<br />
因为我们在旋转某个点的时候，这个点的整个子树都会一起上升 <span
class="math inline">\(1\)</span> 层<br />
因此我们先转 <span class="math inline">\(v\)</span>，后转 <span
class="math inline">\(u\)</span> 是可行的<br />
（见下图模拟，我们依然需要将 <span class="math inline">\(1\)</span>
号点转到根上）</p>
<p><img src="/images/LCT8.png" /></p>
<p><span class="math inline">\(1,2,3\)</span> 号点共线，因此先转 <span
class="math inline">\(2\)</span> 号点，再转 <span
class="math inline">\(1\)</span> 号点</p>
<p><img src="/images/LCT13.png" /></p>
<p><img src="/images/LCT14.png" /></p>
<p><span class="math inline">\(1,4,5\)</span> 号点共线，因此先转 <span
class="math inline">\(4\)</span> 号点，再转 <span
class="math inline">\(1\)</span> 号点</p>
<p><img src="/images/LCT15.png" /></p>
<p><img src="/images/LCT16.png" /></p>
<p>可见，<code>双旋Splay</code> 不仅将我们需要的点转到了根上<br />
而且将原来的不优美的链，变得优美了一些些<br />
高度也就降低了<br />
因此 <code>双旋Splay</code> 更优</p>
<p>代码如下：</p>
<pre class="cpp"><code>void splay(int x)&#123;
    for(int f=fa[x];f;f=fa[x])&#123;
        if(fa[f]!=0) rotate(get(x)==get(f)?f:x);
        rotate(x);
    &#125;
&#125;
//忘记了 get 函数是做什么的，去前面看看吧xwx</code></pre>
<p>现在我们学会了
<code>Splay操作</code>，那么其实也就很简单了，只需要像普通的二叉搜索树一样进行操作基本就行了，记住每次操作完后，将最后操作的点通过
<code>Splay操作</code> 转到根上去就可以了</p>
<h3 id="插入-1">插入</h3>
<p>因为 <code>Splay</code>
本质上也是二叉搜索树，因此它满足二叉搜索树有的所有性质<br />
插入方式和普通二叉搜索树一样，记住最后将插入的那个点旋转到根上即可~</p>
<p>代码如下：</p>
<pre class="cpp"><code>void insert(int x)&#123;
    if(root==0)&#123;
        val[++tot]=x;
        cnt[tot]++;
        pushup(tot);
        root=tot;
        return;
    &#125;
    int f=0,pos=root;
    while(true)&#123;
        if(val[pos]==x)&#123;
            cnt[pos]++;
            pushup(pos);
            pushup(f);
            splay(pos);//记住splay！！！
            return;
        &#125;
        f=pos;
        pos=son[pos][x&gt;val[pos]];
        if(pos==0)&#123;
            val[++tot]=x;
            cnt[tot]++;
            fa[tot]=f;
            son[f][x&gt;val[f]]=tot;
            pushup(tot);
            pushup(f);
            splay(tot);//记住splay！！！
            return;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="删除-1">删除</h3>
<p>删除操作相对比较复杂<br />
需要先将要删的这个点转到根上<br />
如果这个点的 <span class="math inline">\(cnt\)</span> 值大于 <span
class="math inline">\(1\)</span>，那么直接将 <span
class="math inline">\(cnt[pos] \gets  cnt[pos]-1\)</span> 即可
然后再找到这个点的前驱<br />
将前驱作为新的根，合并两颗子树</p>
<p>建议先去学习：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9F%A5%E8%AF%A2%E5%89%8D%E9%A9%B1">查询
<span class="math inline">\(v\)</span> 这个值的前驱</a><br />
</li>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E5%90%88%E5%B9%B6%E4%B8%A4%E9%A2%97%E5%AD%90%E6%A0%91">怎么合并
<span class="math inline">\(u,v\)</span> 这两棵子树</a></li>
</ul>
<p>代码如下：</p>
<pre class="cpp"><code>void del(int x)&#123;
    selrank(x);//这里的作用是将x转到根上
    if(cnt[root]&gt;1)&#123;
        cnt[root]--;
        pushup(root);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]==0)&#123;
        clear(root);
        root=0;
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]!=0)&#123;
        int past=root;
        root=son[root][1];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    if(son[root][0]!=0&amp;&amp;son[root][1]==0)&#123;
        int past=root;
        root=son[root][0];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    int past=root;
    int pos=selpre();//此时的pos已经成为根了，所以不用splay操作了
    fa[son[past][1]]=pos;
    son[pos][1]=son[past][1];
    clear(past);
    pushup(root);
&#125;</code></pre>
<h3 id="更多操作-1">更多操作</h3>
<p>比如：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%90%8D">查询
<span class="math inline">\(v\)</span> 这个值的排名</a><br />
</li>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%90%8D%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC">查询
<span class="math inline">\(x\)</span> 这个排名的值</a><br />
</li>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9F%A5%E8%AF%A2%E5%89%8D%E9%A9%B1">查询
<span class="math inline">\(v\)</span> 这个值的前驱</a><br />
</li>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%BB%A7">查询
<span class="math inline">\(v\)</span> 这个值的后继</a><br />
</li>
<li><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E5%90%88%E5%B9%B6%E4%B8%A4%E9%A2%97splay%E6%A0%91">怎么合并
<span class="math inline">\(u,v\)</span> 这两棵子树</a><br />
</li>
<li>……………………</li>
</ul>
<h4 id="查询排名">查询排名</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C-1">返回</a></p>
<p>查询 <span class="math inline">\(x\)</span>
这个值的排名可以分为三种情况：<br />
设当前访问到的点是 <span class="math inline">\(pos\)</span>，答案为
<span class="math inline">\(ans\)</span>，最开始 <span
class="math inline">\(ans \gets 1\)</span>（因为排名至少为 <span
class="math inline">\(1\)</span>）</p>
<ol type="1">
<li><span class="math inline">\(x &gt; val[pos]\)</span>：说明 <span
class="math inline">\(pos\)</span> 这个点的左子树和 <span
class="math inline">\(pos\)</span> 这个点的值都小于 <span
class="math inline">\(x\)</span>，那么排名至少为 <span
class="math inline">\(cnt[son[pos][0]]+cnt[pos]\)</span>，即 <span
class="math inline">\(ans \gets ans+cnt[son[pos][0]]+cnt[pos]\)</span>
然后继续向右子树递归答案，则 <span class="math inline">\(pos \gets
son[pos][1]\)</span><br />
</li>
<li><span class="math inline">\(x = val[pos]\)</span>：说明 <span
class="math inline">\(pos\)</span> 的左子树的值都小于 <span
class="math inline">\(x\)</span>，并且 <span
class="math inline">\(pos\)</span> 这个点的值刚好等于 <span
class="math inline">\(x\)</span>，因此排名就应该是 <span
class="math inline">\(ans \gets ans+siz[son[pos][0]]\)</span><br />
</li>
<li><span class="math inline">\(x &lt; val[pos]\)</span>：说明 <span
class="math inline">\(pos\)</span> 的左子树都有比 <span
class="math inline">\(x\)</span>
大的值，因此此时不能对答案进行贡献，继续递归左子树求解，即 <span
class="math inline">\(pos \gets son[pos][1]\)</span></li>
</ol>
<p>代码如下：</p>
<pre class="cpp"><code>int selrank(int x)&#123;
    int res=0,pos=root;
    while(true)&#123;
        if(x==val[pos])&#123;
            splay(pos);//将pos转到根后，其左子树就是答案，其实和前文表述是一样的
            return siz[pos[son][0]]+1;
        &#125;
        if(now==0) break;
        if(x&lt;val[pos]) pos=son[pos][0];
        else&#123;
            res+=siz[son[pos][0]]+cnt[pos];
            pos=son[pos][1];
        &#125;
    &#125;
    return res+1;   
&#125;</code></pre>
<h4 id="查询排名对应的值">查询排名对应的值</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C-1">返回</a></p>
<p>查询排名对应的值其实和查询值对应的排名很相像<br />
设当前访问到的点是 <span class="math inline">\(pos\)</span>，要找排名为
<span class="math inline">\(x\)</span> 的值<br />
一样分为3种情况：</p>
<ol type="1">
<li><span class="math inline">\(x &gt;
siz[son[pos][0]]+cnt[pos]\)</span>：说明答案在 <span
class="math inline">\(pos\)</span> 的右子树，因此将 <span
class="math inline">\(x \gets
x-(siz[son[pos][0]]+cnt[pos])\)</span>，再递归右子树（<span
class="math inline">\(pos \gets son[pos][1]\)</span>）即可<br />
</li>
<li><span class="math inline">\(siz[son[pos][0]] &lt; x \le
siz[son[pos][0]]+cnt[pos]\)</span>：说明答案就是 <span
class="math inline">\(val[pos]\)</span> 直接返回答案即可<br />
</li>
<li><span class="math inline">\(x \le
siz[son[pos][0]]\)</span>：说明答案在 <span
class="math inline">\(pos\)</span> 的左子树，递归左子树（<span
class="math inline">\(pos \gets son[pos][0]\)</span>）继续求解即可</li>
</ol>
<p>代码如下：</p>
<pre class="cpp"><code>int selval(int x)&#123;
    int pos=root;
    while(true)&#123;
        if(x&lt;=siz[son[pos][0]])&#123;
            pos=son[pos][0];
            continue;
        &#125;
        x-=siz[son[pos][0]]+cnt[pos];
        if(x&lt;=0)&#123;
            splay(pos);//记住splay！！！
            return val[pos];
        &#125;
        pos=son[pos][1];
    &#125;
&#125;</code></pre>
<h4 id="查询前驱">查询前驱</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C-1">返回</a></p>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E5%88%A0%E9%99%A4-1">返回删除操作</a></p>
<p>前驱被定义为比 <span class="math inline">\(x\)</span>
小的数中最大的数<br />
因此我们只需要从根的左子树开始，一直跳右儿子即可</p>
<p>代码如下：</p>
<pre class="cpp"><code>int selpre()&#123;
    int pos=son[root][0];
    while(son[pos][1]!=0) pos=son[pos][1];
    splay(pos);//记住splay！！！
    return pos;
&#125;</code></pre>
<p>注意：这个是找的是当前<strong>根所对应的值</strong>的前驱，如果需要查找任意一个数的前驱，可以先插入这个数，查完后再删除即可</p>
<p>注意2：删除操作用的是上面的找<strong>根所对应的值</strong>的前驱，因此并不会出现：调用
<code>del</code> 又调用 <code>selpre</code> 又调用 <code>del</code>
这种死循环情况</p>
<p>也就是：</p>
<pre class="cpp"><code>int selpre_val(int x)&#123;
    int res;
    insert(x);
    res=val[selpre()];
    del(x);
    return res;
&#125;</code></pre>
<h4 id="查询后继">查询后继</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C-1">返回</a></p>
<p>查找后继和前驱基本一致，只是开始从根的左儿子变成了右儿子，跳左儿子变成了跳右儿子</p>
<pre class="cpp"><code>int selnext()&#123;
    int pos=son[root][1];
    while(son[pos][0]!=0) pos=son[pos][0];
    splay(pos);//记住splay！！！
    return pos;
&#125;</code></pre>
<p>查找任意一个数的后继和查找任意一个数的前驱是同样的道理：</p>
<pre class="cpp"><code>int selpre_val(int x)&#123;
    int res;
    insert(x);
    res=val[selnext()];
    del(x);
    return res;
&#125;</code></pre>
<h4 id="合并两颗splay树">合并两颗Splay树</h4>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C-1">返回</a></p>
<p><a
target="_blank" rel="noopener" href="https://yzljyawa.github.io/OI/LCT%E5%AD%A6%E4%B9%A0/#%E5%88%A0%E9%99%A4-1">返回删除操作</a></p>
<p>两颗 <code>Splay树</code>
想要合并，前提条件是一颗树的最大值小于另一棵树的最大值，否则不能合并</p>
<p>合并分为三种情况</p>
<ol type="1">
<li>两边子树均为空，不用管</li>
<li>一边子树为空，直接把不为空的子树的根作为合并后的根即可</li>
<li>两边子树均不为空，将第一颗子树的最大值转到根上，将左儿子设为另一颗树的根，<span
class="math inline">\(fa\)</span>
数组也跟着更新即可，最后合并出的根就是第一颗子树的根</li>
</ol>
<p>为什么要将一棵树的最大值转到根后再合并？因为这样才能保证第一颗子树的右儿子是空的，才能够合并上去</p>
<p>代码如下：</p>
<pre class="cpp"><code>int merge(int x,int y)&#123;//这里传的是两个树的根，返回值是合并后的根
    if(x==0||y==0) return x+y;
    int pos=x;
    while(son[pos][1]!=0) pos=son[pos][1];
    splay(pos);
    son[pos][1]=y;
    fa[y]=pos;
    pushup(pos);
    return pos;
&#125;</code></pre>
<p>ps：在删除操作的时候，一般直接把合并操作也写在删除操作中，似乎除了删除操作就不会用到合并操作了？</p>
<h3 id="代码-1">代码</h3>
<p>至此，你已经会了 Splay 的绝大多数操作了<br />
<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3369">板子</a>的代码也放在这里了~</p>
<p>ps：亲测本人 Splay 代码可以通过<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6136">加强版模板题</a></p>
<p>代码如下：</p>
<pre class="cpp"><code>// Problem: P3369 【模板】普通平衡树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3369
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+10;
int n,x,tot,root,val[MAXN],siz[MAXN],cnt[MAXN],fa[MAXN],son[MAXN][2];
inline int read()&#123;
    register int s=0,w=1;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)w=-1;ch=getchar();&#125;
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)s=s*10+ch-&#39;0&#39;,ch=getchar();
    return s*w;
&#125;
void clear(int x)&#123;
    fa[x]=val[x]=son[x][0]=son[x][1]=cnt[x]=siz[x]=0;
&#125;
void pushup(int x)&#123;
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];
&#125;
bool get(int x)&#123;
    return x==son[fa[x]][1];
&#125;
void rotate(int x)&#123;
    int y=fa[x],z=fa[y],ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]!=0) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[y]=x;
    fa[x]=z;
    if(z!=0) son[z][y==son[z][1]]=x;
    pushup(y);
    pushup(x);
&#125;
void splay(int x)&#123;
    for(int f=fa[x];f;f=fa[x])&#123;
        if(fa[f]) rotate(get(x)==get(f)?f:x);
        rotate(x);
    &#125;
    root=x;
&#125;
void insert(int x)&#123;
    if(root==0)&#123;
        val[++tot]=x;
        cnt[tot]++;
        pushup(tot);
        root=tot;
        return;
    &#125;
    int now=root,f=0;
    while(true)&#123;
        if(val[now]==x)&#123;
            cnt[now]++;
            pushup(now);
            pushup(fa[now]);
            splay(now);
            break;
        &#125;
        f=now;now=son[now][x&gt;val[now]];
        if(now==0)&#123;
            val[++tot]=x;
            cnt[tot]++;
            fa[tot]=f;
            son[f][x&gt;val[f]]=tot;
            pushup(tot);
            pushup(f);
            splay(tot);
            break;
        &#125;
    &#125;
&#125;
int selrank(int x)&#123;
    int res=0,now=root;
    while(true)&#123;
        if(x==val[now])&#123;
            splay(now);
            return siz[son[now][0]]+1;
        &#125;
        if(now==0) break;
        if(x&lt;val[now]) now=son[now][0];
        else&#123;
            res+=siz[son[now][0]]+cnt[now];
            now=son[now][1];
        &#125;
    &#125;
    return res+1;
&#125;
int selval(int x)&#123;
    int now=root;
    while(true)&#123;
        if(x&lt;=siz[son[now][0]]&amp;&amp;son[now][0]!=0) now=son[now][0];
        else&#123;
            x-=siz[son[now][0]]+cnt[now];
            if(x&lt;=0)&#123;
                splay(now);
                return val[now];
            &#125;
            now=son[now][1];
        &#125;
    &#125;
&#125;
int selpre()&#123;
    int now=son[root][0];
    while(son[now][1]!=0) now=son[now][1];
    splay(now);
    return root;
&#125;
int selnext()&#123;
    int now=son[root][1];
    while(son[now][0]!=0) now=son[now][0];
    splay(now);
    return root;
&#125;
void del(int x)&#123;
    selrank(x);
    if(cnt[root]&gt;1)&#123;
        cnt[root]--;
        pushup(root);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]==0)&#123;
        clear(root);
        root=0;
        return;
    &#125;
    if(son[root][0]!=0&amp;&amp;son[root][1]==0)&#123;
        int past=root;
        root=son[root][0];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]!=0)&#123;
        int past=root;
        root=son[root][1];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    int past=root;
    int pos=selpre();
    fa[son[past][1]]=pos;
    son[pos][1]=son[past][1];
    clear(past);
    pushup(root);
&#125;
int main()&#123;
    n=read();
    for(int i=1;i&lt;=n;i++)&#123;
        int opt,x;
        opt=read();x=read();
        if(opt==1) insert(x);
        if(opt==2) del(x);
        if(opt==3) cout&lt;&lt;selrank(x)&lt;&lt;endl;
        if(opt==4) cout&lt;&lt;selval(x)&lt;&lt;endl;
        if(opt==5)&#123;insert(x);cout&lt;&lt;val[selpre()]&lt;&lt;endl;del(x);&#125;
        if(opt==6)&#123;insert(x);cout&lt;&lt;val[selnext()]&lt;&lt;endl;del(x);&#125;
    &#125;
    return 0;
&#125;</code></pre>
<p>接下来，就正式进入 <code>LCT</code> 的部分了~</p>
<h2 id="lct">LCT</h2>
<p>现在，你应该已经掌握了所有的前置
芝士，是时候真正进入LCT的部分了！！！</p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yzljyのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yzljy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="yzljyawa/yzljyawa.github.io"
    data-repo-id="R_kgDOMbAUfA"
    data-category="Announcements"
    data-category-id="DIC_kwDOMbAUfM4CiQYe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
