
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>LCT/Splay 学习笔记 | yzljyのBlog</title>
    <meta name="author" content="yzljy" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/yzljy.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YZLJYのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YZLJYのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>LCT/Splay 学习笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/1
        </span>
        
        <span class="category">
            <a href="/categories/OI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                OI
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" style="color: #a5ff4d">
                    学习指南
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/LCT/" style="color: #00beff">
                    LCT
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="color: #e74c3c">
                    平衡树
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="是什么">是什么</h1>
<p>Link-Cut-Tree<br />
一般称作 <code>LCT</code>/<code>虚实链剖分</code><br />
ps： LCT 不能称作 <code>动态树</code>，<code>动态树</code>
指的是一类问题。<br />
由著名巨佬 Tarjan 发明（对，又是他）<br />
用于解决动态的树上路径/子树问题（统称为<strong>动态树</strong>问题）<br />
对于普通的树上问题，比如：</p>
<blockquote>
<p>给定一颗 <span class="math inline">\(n\)</span>
个节点的树，每个节点均有权值，需要维护三个操作：<br />
1.查询 <span class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 路径上的权值和<br />
2.查询以 <span class="math inline">\(u\)</span> 为根的子树的权值和<br />
3.将 <span class="math inline">\(u\)</span> 点的权值修改为 <span
class="math inline">\(val\)</span></p>
</blockquote>
<p>那么这是一道很板的 <del>熟练剖粪</del> 树链剖分题<br />
但假如我们还需要维护两个操作：</p>
<blockquote>
<p>4.将 <span class="math inline">\(u,v\)</span>
这条边断开（如果有边的话）<br />
5.将 <span class="math inline">\(u,v\)</span> 连接起来（若 <span
class="math inline">\(u,v\)</span> 不在同一连通块内）</p>
</blockquote>
<p>那么现在，普通的树剖就没有办法解决了<br />
这时候，我们就需要用到 LCT</p>
<h1 id="怎么做">怎么做</h1>
<p><strong>变量声明</strong></p>
<blockquote>
<p><span class="math inline">\(root\)</span> 表示树的根<br />
<span class="math inline">\(tot\)</span> 表示当前树的节点个数<br />
<span class="math inline">\(val_{i}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的权值<br />
<span class="math inline">\(son_{i,0}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的左儿子<br />
<span class="math inline">\(son_{i,1}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的右儿子<br />
<span class="math inline">\(fa_{i}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的父亲<br />
<span class="math inline">\(tag_{i}\)</span> 表示 <span
class="math inline">\(i\)</span> 节点的翻转标记<br />
<span class="math inline">\(cnt_{i}\)</span> 表示 <span
class="math inline">\(i\)</span>
节点存储的数量（同样的值放在同一个节点）<br />
<span class="math inline">\(siz_{i}\)</span> 表示以 <span
class="math inline">\(i\)</span> 节点为根的子树大小</p>
</blockquote>
<p>先将 LCT 模板题放在 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3690">这里</a><br />
其实 LCT 的码量并不算太大，但是就比较难理解</p>
<p>前置芝士：二叉搜索树，Splay</p>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>我们在对一个序列进行各种操作的时候，<br />
可能会遇见让你插入某个数，删除某个数，还需要让你随时都保证有序，<br />
假如我们对一个普通的数组这样操作的话，如果从中间插入和删除之类的，需要用到
<span class="math inline">\(O(n)\)</span> 的时间来维护序列的有序，<br />
这样显然无法接受，我们需要优化时间复杂度。<br />
考虑将序列转移到一颗二叉树上。</p>
<h3 id="输出">输出</h3>
<p>我们让二叉树的中序遍历的结果，就是原先的序列。</p>
<p>那么怎么维护有序？假设我们需要维护单调递增的序列，对于每个节点 <span
class="math inline">\(i\)</span> 都满足 <span
class="math inline">\(val_{son_{i,0}} &lt; val_{i} &lt;
val_{son_{i,1}}\)</span> 即可。</p>
<p>这样的话，经过中序遍历后得到的结果，就是单调递增的原序列了。</p>
<h3 id="插入">插入</h3>
<p>设插入的值为 <span class="math inline">\(v\)</span>。<br />
根据前面所讲的输出方式，我们在插入的时候，使二叉树依然满足性质即可。<br />
最开始令 <span class="math inline">\(pos \gets root\)</span>。<br />
（ps：<span class="math inline">\(a \gets b\)</span> 表示将 <span
class="math inline">\(b\)</span> 的值赋给 <span
class="math inline">\(a\)</span>）<br />
一直重复下面这个式子，直到 <span
class="math inline">\(pos=0\)</span>。</p>
<p><span class="math display">\[
\left\{\begin{matrix}
  pos \gets son_{pos,0}(v&lt;val_{pos})\\
  pos \gets son_{pos,1}(v&gt;val_{pos})
\end{matrix}\right.
\]</span></p>
<p><span class="math inline">\(pos=0\)</span> 后，我们就可以将 <span
class="math inline">\(tot \gets tot+1\)</span> 并将新的这个权值 <span
class="math inline">\(v\)</span> 赋给 <span
class="math inline">\(val_{tot}\)</span><br />
记住插入后要更新 <span class="math inline">\(fa_{tot}\)</span> 和 <span
class="math inline">\(son_{fa_{tot},0/1}\)</span><br />
这样插入操作就完成了！<br />
代码如下：</p>
<pre class="cpp"><code>void insert(int v)&#123;
    int pos=root;
    int f=0;
    while(true)&#123;
        if(pos==0)&#123;
            val[++tot]=v;
            fa[tot]=f;
            if(f!=0) son[f][v&gt;val[f]]=v;
            break;
        &#125;
        fa=pos;
        if(v==val[pos])&#123;
            cnt[pos]++;
            break;
        &#125;
        pos=son[pos][v&gt;val[pos]];
    &#125;
&#125;</code></pre>
<h3 id="查找某个值所在的位置">查找某个值所在的位置</h3>
<p>设需要查找的值为 <span class="math inline">\(v\)</span>（保证 <span
class="math inline">\(v\)</span> 存在）。<br />
那么就和插入操作很类似了，只是我们当 <span
class="math inline">\(v=val_{pos}\)</span> 的时候，直接返回 <span
class="math inline">\(pos\)</span> 即可<br />
代码如下：</p>
<pre class="cpp"><code>int selpos(int v)&#123;
    int pos=root;
    while(true)&#123;
        if(val[pos]==v) return pos;
        pos=son[pos][v&gt;val[pos]];
    &#125;
&#125;</code></pre>
<h3 id="删除">删除</h3>
<p>设需要删除的值为 <span class="math inline">\(v\)</span>。<br />
删除操作需要先找到 <span class="math inline">\(v\)</span>
的位置，删除后，合并他的左右两颗子树即可。<br />
代码如下：</p>
<pre class="cpp"><code>void clear(int pos)&#123;
    val[pos]=son[pos][0]=son[pos][1]=fa[pos]=0;
&#125;//清空节点pos
void del(int v)&#123;
    int pos=selpos(v);
    if(son[pos][0]==0&amp;&amp;son[pos][1]==0)&#123;
        clear(pos);
        return;
    &#125;
    if(son[pos][0]==0&amp;&amp;son[pos][1]!=0)&#123;
        fa[son[pos][1]]=fa[pos];
        if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][1];
        clear(pos);
        return;
    &#125;
    if(son[pos][0]!=0&amp;&amp;son[pos][1]==0)&#123;
        fa[son[pos][0]]=fa[pos];
        if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][0];
        clear(pos);
        return;
    &#125;
    fa[son[pos][0]]=son[pos][1];
    fa[son[pos][1]]=fa[pos];
    if(fa[pos]!=0) son[fa[pos]][val[pos]&gt;val[fa[pos]]]=son[pos][1];
    clear(pos);
&#125;</code></pre>
<h3 id="更多操作">更多操作</h3>
<ul>
<li>查询 <span class="math inline">\(v\)</span> 这个值的排名<br />
</li>
<li>查询 <span class="math inline">\(x\)</span> 这个排名的值<br />
</li>
<li>查询 <span class="math inline">\(v\)</span> 这个值的前驱<br />
</li>
<li>查询 <span class="math inline">\(v\)</span> 这个值的后继</li>
</ul>
<p>请读者自行尝试或者查阅，因为普通的二叉搜索树容易被卡，因此在后文讲解
Splay 时具体讲解。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>空间复杂度：</p>
<blockquote>
<p>我们每次在插入时只会多一个，因此空间复杂度为 <span
class="math inline">\(O(n)\)</span></p>
</blockquote>
<p>时间复杂度：</p>
<blockquote>
<p>理想情况下，<span class="math inline">\(n\)</span>
个数据构成的二叉树的高度为 <span class="math inline">\(\log{n}\)</span>
因此在插入删除时均最多跳 <span class="math inline">\(\log{n}\)</span>
次，最优时间复杂度为 <span
class="math inline">\(O(\log{n})\)</span>。<br />
但是我们可以通过构造如 <code>1 2 3 4 5</code>
这样单调的数据，来使树高变为 <span
class="math inline">\(O(n)\)</span>，此时二叉搜索树退化为<strong>链</strong>，插入和删除时最多会跳
<span class="math inline">\(n\)</span> 次，最劣时间复杂度为 <span
class="math inline">\(O(n)\)</span>。</p>
</blockquote>
<p>总之，普通的二叉搜索树没法保证时间复杂度，我们需要优化。</p>
<h2 id="splay">Splay</h2>
<p>Splay 是一种自平衡的 二叉搜索树。<br />
（ps：关于更多平衡树，以后会讲）</p>
<p>Splay 通过一种叫做 <code>Splay</code>
的操作，防止二叉搜索树退化为链，保证了树高为 <span
class="math inline">\(O(\log{n})\)</span> 级别，保证了各个操作的 <span
class="math inline">\(O(\log{n})\)</span> 时间复杂度。</p>
<h3 id="基础操作">基础操作</h3>
<p>直接上代码吧：</p>
<pre class="cpp"><code>void clear(int x)&#123;
    fa[x]=val[x]=son[x][0]=son[x][1]=cnt[x]=siz[x]=0;
&#125;//清空x节点
void pushup(int x)&#123;
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];
&#125;//更新x节点的子树大小
bool get(int x)&#123;
    return x==son[fa[x]][1];
&#125;//得到点x属于fa[x]的左儿子还是右儿子</code></pre>
<h3 id="旋转操作">旋转操作</h3>
<p>若你学过 Treap
之类的带旋平衡树，这一部分可以选择略过（建议不要略过）。</p>
<p>由中序遍历的性质：同一种中序遍历对应的二叉树不止一棵。<br />
我们可以通过一些操作，在保证中序遍历不变的前提下，来使树高变低。<br />
这种操作就称作 <code>旋转操作</code>，函数一般叫做
<code>rotate</code>。</p>
<h4 id="为什么要旋转">为什么要旋转</h4>
<p>对于这么一棵二叉树。</p>
<p><img src="/images/LCT1.png" /></p>
<p>我们要将其转成这样：</p>
<p><img src="/images/LCT2.png" /></p>
<p>当然也可以转回来，<br />
这样进行一次旋转后，x的高度提高了一层。<br />
看似对总的高度没有影响，<br />
但对于这样的退化成链的情况时：</p>
<p><img src="/images/LCT3.png" /></p>
<p>我们可以通过如下操作，将高度降低。</p>
<ol type="1">
<li>对点 <span class="math inline">\(1\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT4.png" /></p>
<ol start="2" type="1">
<li>再对点 <span class="math inline">\(1\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT5.png" /></p>
<ol start="3" type="1">
<li>继续对点 <span class="math inline">\(1\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT6.png" /></p>
<ol start="4" type="1">
<li>最后对点 <span class="math inline">\(3\)</span>
进行旋转操作，会变成这样：</li>
</ol>
<p><img src="/images/LCT7.png" /></p>
<p>至此，我们成功地通过旋转操作将高度从 <span
class="math inline">\(4\)</span> 降到 <span
class="math inline">\(3\)</span>。<br />
因此旋转操作是可以有效降低树高的。</p>
<h4 id="旋转过程讲解">旋转过程讲解</h4>
<p>我们令要进行 <code>rotate</code> 操作的点为 <span
class="math inline">\(x\)</span>。<br />
令:<br />
<span class="math inline">\(y \gets fa[x]\)</span><br />
<span class="math inline">\(z \gets fa[y]\)</span><br />
<span class="math inline">\(ch \gets get(x)\)</span></p>
<p>根据这两个图：</p>
<p><img src="/images/LCT1.png" /></p>
<p><img src="/images/LCT2.png" /></p>
<p>我们可以发现：<br />
（ps：<span class="math inline">\(a \oplus b\)</span> 表示 "<span
class="math inline">\(a\)</span> 异或 <span
class="math inline">\(b\)</span>"）<br />
（此时的 <span class="math inline">\(ch=0\)</span>）</p>
<ul>
<li><span class="math inline">\(son_{x,ch}\)</span> 没有发生变化<br />
</li>
<li><span class="math inline">\(son_{x,ch \oplus 1}\)</span> 变成了
<span class="math inline">\(y\)</span><br />
</li>
<li><span class="math inline">\(son_{y,ch}\)</span> 从 <span
class="math inline">\(x\)</span> 变成了 <span
class="math inline">\(son_{x,ch \oplus 1}\)</span><br />
</li>
<li>对应的 <span class="math inline">\(fa\)</span>
的的值也会随之变化</li>
</ul>
<p>最后再处理一下先后执行顺序，就可以写出旋转操作的代码啦~~</p>
<h4 id="代码">代码</h4>
<pre class="cpp"><code>void rotate(int x)&#123;
    int y=fa[x],z=fa[y];bool ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]!=0) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[y]=x;
    fa[x]=z;
    if(z!=0) son[z][y==son[z][1]]=x;
    pushup(y);
    pushup(x);
&#125;</code></pre>
<h3 id="splay操作">Splay操作</h3>
<p>Splay 规定，每次操作后，都要将操作的点转到根上，这样的操作就被称为
<code>Splay操作</code>。<br />
怎么转移到根上？暴力一次次往上旋转即可。</p>
<h4 id="单旋splay">单旋Splay</h4>
<p>如果只是像上文那样旋转，也就是从下往上依次转，这样的被称为
<code>单旋Splay</code>。<br />
当出现 <span class="math inline">\(x,y,z\)</span>
三点共线时，我们发现，依此转完后，树高是没有变化的，这样就没法保证时间复杂度（见下面几张图理解）。</p>
<p><img src="/images/LCT8.png" /></p>
<p>我们需要将 <span class="math inline">\(1\)</span> 号点转到根上。</p>
<p>那么我们只需要旋转四次 <span class="math inline">\(1\)</span>
号点就可以了。<br />
转的过程如下：</p>
<p><img src="/images/LCT9.png" /></p>
<p><img src="/images/LCT10.png" /></p>
<p><img src="/images/LCT11.png" /></p>
<p><img src="/images/LCT12.png" /></p>
<p>这样的话，就是“如转”。<br />
我们虽然将 <span class="math inline">\(1\)</span>
号点转到了根上，但是高度并没有降低。<br />
因此当树退化为一条链的时候。<br />
<code>单旋Splay</code> 也就没法保证时间复杂度了。</p>
<p>这时候我们就需要用到 <code>双旋Splay</code>。</p>
<h4 id="双旋splay">双旋Splay</h4>
<p><code>双旋Splay</code> 其实就是在 <code>单旋Splay</code>
的基础上，特殊处理了一下 <span class="math inline">\(u,v,z\)</span>
三点共线的情况<br />
在遇到三点共线的情况时，我们只需要先旋转 <span
class="math inline">\(fa_{u}\)</span> 也就是 <span
class="math inline">\(v\)</span> 点，再旋转 <span
class="math inline">\(u\)</span> 点即可。<br />
因为我们在旋转某个点的时候，这个点的整个子树都会一起上升 <span
class="math inline">\(1\)</span> 层。<br />
因此我们先转 <span class="math inline">\(v\)</span>，后转 <span
class="math inline">\(u\)</span> 是合法的。<br />
（见下图模拟，我们依然需要将 <span class="math inline">\(1\)</span>
号点转到根上）</p>
<p><img src="/images/LCT8.png" /></p>
<p><span class="math inline">\(1,2,3\)</span> 号点共线，因此先转 <span
class="math inline">\(2\)</span> 号点，再转 <span
class="math inline">\(1\)</span> 号点。</p>
<p><img src="/images/LCT13.png" /></p>
<p><img src="/images/LCT14.png" /></p>
<p><span class="math inline">\(1,4,5\)</span> 号点共线，因此先转 <span
class="math inline">\(4\)</span> 号点，再转 <span
class="math inline">\(1\)</span> 号点。</p>
<p><img src="/images/LCT15.png" /></p>
<p><img src="/images/LCT16.png" /></p>
<p>可见，<code>双旋Splay</code> 不仅将我们需要的点转到了根上。<br />
而且将原来的不优美的链，变得优美了一些些。<br />
高度也就降低了。<br />
因此 <code>双旋Splay</code> 更优。</p>
<p>代码如下：</p>
<pre class="cpp"><code>void Splay(int x)&#123;
    for(int f=fa[x];f;f=fa[x])&#123;
        if(fa[f]!=0) rotate(get(x)==get(f)?f:x);
        rotate(x);
    &#125;
&#125;
//忘记了 get 函数是做什么的，去前面看看吧xwx</code></pre>
<p>现在我们学会了
<code>Splay操作</code>，那么其实也就很简单了，只需要像普通的二叉搜索树一样进行操作基本就行了，记住每次操作完后，将最后找到的点通过
<code>Splay操作</code> 转到根上去就可以了。</p>
<h3 id="插入-1">插入</h3>
<p>因为 <code>Splay</code>
本质上也是二叉搜索树，因此它满足二叉搜索树有的所有性质。<br />
插入方式和普通二叉搜索树一样，记住最后将插入的那个点旋转到根上即可~</p>
<p>代码如下：</p>
<pre class="cpp"><code>void insert(int x)&#123;
    if(root==0)&#123;
        val[++tot]=x;
        cnt[tot]++;
        pushup(tot);
        root=tot;
        return;
    &#125;
    int f=0,pos=root;
    while(true)&#123;
        if(val[pos]==x)&#123;
            cnt[pos]++;
            pushup(pos);
            pushup(f);
            Splay(pos);//记住Splay操作！！！
            return;
        &#125;
        f=pos;
        pos=son[pos][x&gt;val[pos]];
        if(pos==0)&#123;
            val[++tot]=x;
            cnt[tot]++;
            fa[tot]=f;
            son[f][x&gt;val[f]]=tot;
            pushup(tot);
            pushup(f);
            Splay(tot);//记住Splay操作！！！
            return;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="查询排名">查询排名</h3>
<p>设当前访问到的点是 <span class="math inline">\(pos\)</span>，答案为
<span class="math inline">\(ans\)</span>，最开始 <span
class="math inline">\(ans \gets 1\)</span>（因为排名至少为 <span
class="math inline">\(1\)</span>）。<br />
查询 <span class="math inline">\(x\)</span>
这个值的排名可以分为三种情况：</p>
<ol type="1">
<li><span class="math inline">\(x &gt; val_{pos}\)</span>：<br />
说明 <span class="math inline">\(pos\)</span> 这个点的左子树的所有值和
<span class="math inline">\(pos\)</span> 这个点的值都小于 <span
class="math inline">\(x\)</span><br />
那么排名至少为 <span
class="math inline">\(cnt_{son_{pos,0}}+cnt_{pos}\)</span><br />
即 <span class="math inline">\(ans \gets
ans+cnt_{son_{pos,0}}+cnt_{pos}\)</span><br />
然后继续到右子树中计算答案，即 <span class="math inline">\(pos \gets
son_{pos,1}\)</span><br />
</li>
<li><span class="math inline">\(x = val_{pos}\)</span>：<br />
说明 <span class="math inline">\(pos\)</span> 的左子树的所有值都小于
<span class="math inline">\(x\)</span><br />
并且 <span class="math inline">\(pos\)</span> 这个点的值刚好等于 <span
class="math inline">\(x\)</span><br />
因此排名就应该是 <span class="math inline">\(ans \gets
ans+siz_{son_{pos,0}}\)</span><br />
</li>
<li><span class="math inline">\(x &lt; val_{pos}\)</span>：<br />
说明 <span class="math inline">\(pos\)</span> 的左子树有比 <span
class="math inline">\(x\)</span> 大的值。<br />
因此此时不能对答案进行计算。<br />
需要继续到左子树中计算答案，即 <span class="math inline">\(pos \gets
son_{pos,1}\)</span></li>
</ol>
<p>代码如下：</p>
<pre class="cpp"><code>int selrank(int x)&#123;
    int res=0,pos=root;
    while(true)&#123;
        if(x==val[pos])&#123;
            Splay(pos);//将pos转到根后，其左子树就是答案，其实和前文表述是一样的
            return siz[pos[son][0]]+1;
        &#125;
        if(now==0) break;
        if(x&lt;val[pos]) pos=son[pos][0];
        else&#123;
            res+=siz[son[pos][0]]+cnt[pos];
            pos=son[pos][1];
        &#125;
    &#125;
    return res+1;   
&#125;</code></pre>
<h3 id="查询排名对应的值">查询排名对应的值</h3>
<p>查询排名对应的值其实和查询值对应的排名很像。<br />
设当前访问到的点是 <span class="math inline">\(pos\)</span>，要找排名为
<span class="math inline">\(x\)</span> 的值。<br />
一样分为3种情况：</p>
<ol type="1">
<li><span class="math inline">\(x &gt;
siz_{son_{pos,0}}+cnt_{pos}\)</span>：<br />
说明答案在 <span class="math inline">\(pos\)</span> 的右子树中。<br />
因此将 <span class="math inline">\(x \gets
x-(siz_{son_{pos,0}}+cnt_{pos})\)</span><br />
再到右子树（<span class="math inline">\(pos \gets
son_{pos,1}\)</span>）中寻找答案即可。<br />
</li>
<li><span class="math inline">\(siz_{son_{pos,0}} &lt; x \le
siz_{son_{pos,0}}+cnt_{pos}\)</span>：<br />
说明答案就是 <span class="math inline">\(val_{pos}\)</span><br />
直接返回答案即可。<br />
</li>
<li><span class="math inline">\(x \le siz_{son_{pos,0}}\)</span>：<br />
说明答案在 <span class="math inline">\(pos\)</span> 的左子树。<br />
到左子树（<span class="math inline">\(pos \gets
son_{pos,0}\)</span>）中继续寻找答案即可。</li>
</ol>
<p>代码如下：</p>
<pre class="cpp"><code>int selval(int x)&#123;
    int pos=root;
    while(true)&#123;
        if(x&lt;=siz[son[pos][0]])&#123;
            pos=son[pos][0];
            continue;
        &#125;
        x-=siz[son[pos][0]]+cnt[pos];
        if(x&lt;=0)&#123;
            Splay(pos);//记住Splay操作！！！
            return val[pos];
        &#125;
        pos=son[pos][1];
    &#125;
&#125;</code></pre>
<h3 id="查询前驱">查询前驱</h3>
<p>前驱被定义为比 <span class="math inline">\(x\)</span>
小的数中最大的数。<br />
因此我们只需要从根的左子树开始，一直跳右儿子即可。</p>
<p>代码如下：</p>
<pre class="cpp"><code>int selpre()&#123;
    int pos=son[root][0];
    while(son[pos][1]!=0) pos=son[pos][1];
    Splay(pos);//记住Splay操作！！！
    return pos;
&#125;</code></pre>
<p>注意：这个是找的是当前<strong>根所对应的值</strong>的前驱，如果需要查找任意一个数的前驱，可以先插入这个数，查完后再删除即可。</p>
<p>也就是：</p>
<pre class="cpp"><code>int selpre_val(int x)&#123;
    int res;
    insert(x);
    res=val[selpre()];
    del(x);
    return res;
&#125;</code></pre>
<h3 id="查询后继">查询后继</h3>
<p>查找后继和前驱基本一致，只是开始从根的左儿子变成了右儿子，跳左儿子变成了跳右儿子。</p>
<pre class="cpp"><code>int selnext()&#123;
    int pos=son[root][1];
    while(son[pos][0]!=0) pos=son[pos][0];
    Splay(pos);//记住Splay操作！！！
    return pos;
&#125;</code></pre>
<p>查找任意一个数的后继和查找任意一个数的前驱是同样的道理：</p>
<pre class="cpp"><code>int selpre_val(int x)&#123;
    int res;
    insert(x);
    res=val[selnext()];
    del(x);
    return res;
&#125;</code></pre>
<h3 id="合并两颗splay树">合并两颗Splay树</h3>
<p>两颗 <code>Splay树</code>
想要快速合并，前提条件是一棵树的最大值小于另一棵树的最小值，否则无法做到快速合并。</p>
<p>合并分为三种情况:</p>
<ol type="1">
<li>两棵子树均为空，不用管。<br />
</li>
<li>一棵子树为空，直接把不为空的子树的根作为合并后的根即可。<br />
</li>
<li>两边子树均不为空，将第一棵子树的最大值转到根上，将左儿子设为另一颗树的根，<span
class="math inline">\(fa\)</span>
数组也跟着更新即可，最后合并出的根就是第一棵子树的根。</li>
</ol>
<p>为什么要将一棵树的最大值转到根后再合并？因为这样才能保证第一棵子树的右儿子是空的，才能够合并上去。</p>
<p>代码如下：</p>
<pre class="cpp"><code>int merge(int x,int y)&#123;//这里传的是两个树的根，返回值是合并后的根
    if(x==0||y==0) return x+y;
    int pos=x;
    while(son[pos][1]!=0) pos=son[pos][1];
    Splay(pos);//记住Splay操作！！！
    son[pos][1]=y;
    fa[y]=pos;
    pushup(pos);
    return pos;
&#125;</code></pre>
<h3 id="删除-1">删除</h3>
<p>删除操作相对比较复杂。<br />
因此放在最后面来讲 需要先将要删的这个点转到根上。<br />
如果这个点的 <span class="math inline">\(cnt\)</span> 值大于 <span
class="math inline">\(1\)</span>，那么直接将 <span
class="math inline">\(cnt_{pos} \gets  cnt_{pos}-1\)</span> 即可。
然后再找到这个点的前驱。<br />
将前驱作为新的根，合并两颗子树。</p>
<p>为什么要找前驱？<br />
因为在当前你要删除的这个点的右子树中，只有前驱可以<strong>保证</strong>没有右儿子。<br />
合并两棵子树也就是 <span class="math inline">\(O(1)\)</span> 的了。</p>
<p>代码如下：</p>
<pre class="cpp"><code>void del(int x)&#123;
    selrank(x);//这里的作用是将x转到根上
    if(cnt[root]&gt;1)&#123;
        cnt[root]--;
        pushup(root);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]==0)&#123;
        clear(root);
        root=0;
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]!=0)&#123;
        int past=root;
        root=son[root][1];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    if(son[root][0]!=0&amp;&amp;son[root][1]==0)&#123;
        int past=root;
        root=son[root][0];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    int past=root;
    int pos=selpre();//此时的pos已经成为根了，所以不用Splay操作了
    fa[son[past][1]]=pos;
    son[pos][1]=son[past][1];
    clear(past);
    pushup(root);
&#125;</code></pre>
<h3 id="代码-1">代码</h3>
<p>至此，你已经会了 Splay 的绝大多数操作了<br />
<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3369">板子</a>的代码也放在这里了~</p>
<p>ps：亲测本人 Splay 代码可以通过<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6136">加强版模板题</a></p>
<p>代码如下：</p>
<pre class="cpp"><code>// Problem: P3369 【模板】普通平衡树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3369
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+10;
int n,x,tot,root,val[MAXN],siz[MAXN],cnt[MAXN],fa[MAXN],son[MAXN][2];
inline int read()&#123;
    register int s=0,w=1;
    char ch=getchar();
    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)w=-1;ch=getchar();&#125;
    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)s=s*10+ch-&#39;0&#39;,ch=getchar();
    return s*w;
&#125;
void clear(int x)&#123;
    fa[x]=val[x]=son[x][0]=son[x][1]=cnt[x]=siz[x]=0;
&#125;
void pushup(int x)&#123;
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+cnt[x];
&#125;
bool get(int x)&#123;
    return x==son[fa[x]][1];
&#125;
void rotate(int x)&#123;
    int y=fa[x],z=fa[y],ch=get(x);
    son[y][ch]=son[x][ch^1];
    if(son[x][ch^1]!=0) fa[son[x][ch^1]]=y;
    son[x][ch^1]=y;
    fa[y]=x;
    fa[x]=z;
    if(z!=0) son[z][y==son[z][1]]=x;
    pushup(y);
    pushup(x);
&#125;
void splay(int x)&#123;
    for(int f=fa[x];f;f=fa[x])&#123;
        if(fa[f]) rotate(get(x)==get(f)?f:x);
        rotate(x);
    &#125;
    root=x;
&#125;
void insert(int x)&#123;
    if(root==0)&#123;
        val[++tot]=x;
        cnt[tot]++;
        pushup(tot);
        root=tot;
        return;
    &#125;
    int now=root,f=0;
    while(true)&#123;
        if(val[now]==x)&#123;
            cnt[now]++;
            pushup(now);
            pushup(fa[now]);
            splay(now);
            break;
        &#125;
        f=now;now=son[now][x&gt;val[now]];
        if(now==0)&#123;
            val[++tot]=x;
            cnt[tot]++;
            fa[tot]=f;
            son[f][x&gt;val[f]]=tot;
            pushup(tot);
            pushup(f);
            splay(tot);
            break;
        &#125;
    &#125;
&#125;
int selrank(int x)&#123;
    int res=0,now=root;
    while(true)&#123;
        if(x==val[now])&#123;
            splay(now);
            return siz[son[now][0]]+1;
        &#125;
        if(now==0) break;
        if(x&lt;val[now]) now=son[now][0];
        else&#123;
            res+=siz[son[now][0]]+cnt[now];
            now=son[now][1];
        &#125;
    &#125;
    return res+1;
&#125;
int selval(int x)&#123;
    int now=root;
    while(true)&#123;
        if(x&lt;=siz[son[now][0]]&amp;&amp;son[now][0]!=0) now=son[now][0];
        else&#123;
            x-=siz[son[now][0]]+cnt[now];
            if(x&lt;=0)&#123;
                splay(now);
                return val[now];
            &#125;
            now=son[now][1];
        &#125;
    &#125;
&#125;
int selpre()&#123;
    int now=son[root][0];
    while(son[now][1]!=0) now=son[now][1];
    splay(now);
    return root;
&#125;
int selnext()&#123;
    int now=son[root][1];
    while(son[now][0]!=0) now=son[now][0];
    splay(now);
    return root;
&#125;
void del(int x)&#123;
    selrank(x);
    if(cnt[root]&gt;1)&#123;
        cnt[root]--;
        pushup(root);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]==0)&#123;
        clear(root);
        root=0;
        return;
    &#125;
    if(son[root][0]!=0&amp;&amp;son[root][1]==0)&#123;
        int past=root;
        root=son[root][0];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    if(son[root][0]==0&amp;&amp;son[root][1]!=0)&#123;
        int past=root;
        root=son[root][1];
        fa[root]=0;
        clear(past);
        return;
    &#125;
    int past=root;
    int pos=selpre();
    fa[son[past][1]]=pos;
    son[pos][1]=son[past][1];
    clear(past);
    pushup(root);
&#125;
int main()&#123;
    n=read();
    for(int i=1;i&lt;=n;i++)&#123;
        int opt,x;
        opt=read();x=read();
        if(opt==1) insert(x);
        if(opt==2) del(x);
        if(opt==3) cout&lt;&lt;selrank(x)&lt;&lt;endl;
        if(opt==4) cout&lt;&lt;selval(x)&lt;&lt;endl;
        if(opt==5)&#123;insert(x);cout&lt;&lt;val[selpre()]&lt;&lt;endl;del(x);&#125;
        if(opt==6)&#123;insert(x);cout&lt;&lt;val[selnext()]&lt;&lt;endl;del(x);&#125;
    &#125;
    return 0;
&#125;</code></pre>
<p>接下来，就正式进入 <code>LCT</code> 的部分了~</p>
<h2 id="lct">LCT</h2>
<p>现在，你应该已经掌握了所有的前置芝士，是时候真正进入LCT的部分了！！！</p>
<h3 id="讲解">讲解</h3>
<p>首先，我们称原来的树叫做<strong>原树</strong>。<br />
现在，我们为了实现删边和连边的操作，引入一棵新的树，叫做<strong>辅助树</strong>。<br />
注意！！！<strong>千万千万</strong>不要把这两棵弄混了！！！<br />
在下文中，我会将有关这两棵树的地方用不同的颜色标出。<br />
这是<span
class="math inline">\(\textcolor{green}{原树}\)</span>，这是<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>。</p>
<p>既然 LCT
又叫做<code>虚实链剖分</code>，那么肯定和一般的树剖有相似之处。<br />
我们定义有两种树边，一种是<code>实边</code>，一种是<code>虚边</code>，对应的连接的儿子也就分别是<code>实儿子</code>和<code>虚儿子</code>。<br />
<span
class="math inline">\(\textcolor{green}{原树}\)</span>中有儿子的节点一定有且仅有<strong>一条</strong><code>实边</code>（没有儿子当然也就没有<code>实边</code>），可以有任意多（包括
<span class="math inline">\(0\)</span>）条<code>虚边</code>。<br />
虚实链都是可以自由变换的，这个特点使得 LCT 可以实现 动态树
这一类问题。<br />
将由<code>实边</code>构成的树上的一条链称为<code>实链</code>。显然，每个点都会且仅会在<strong>一条</strong><code>实链</code>上。</p>
<p><span
class="math inline">\(\textcolor{green}{原树}\)</span>上的每一条实链，在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上对应的则是一棵
Splay。</p>
<p><span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>有如下性质：</p>
<ol type="1">
<li><span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上每个点与<span
class="math inline">\(\textcolor{green}{原树}\)</span>上的每个点一一对应。<br />
</li>
<li>对<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上每一棵 Splay
树进行<code>中序遍历</code>，得到的则是<span
class="math inline">\(\textcolor{green}{原树}\)</span>上这条对应的<code>实链</code><strong>从上到下</strong>的路径。<br />
</li>
<li><span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上每一棵 Splay
树的根节点是有父亲的。定义为<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上这棵 Splay
对应的<span
class="math inline">\(\textcolor{green}{原树}\)</span>上的那条<code>实链</code>的最顶端的节点的父亲。（特别的，最顶端的
Splay 的根节点是没有父亲节点的，或者说它的父亲节点是 <span
class="math inline">\(0\)</span>）<br />
</li>
<li>在 <span class="math inline">\(3\)</span>
中提到的<code>父亲关系</code>的特点是<strong>儿子认父亲，父亲不认儿子</strong>。而<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上的每一棵 Splay
内部的<code>父亲关系</code>则是<strong>儿子认父亲，父亲认儿子</strong>的。<br />
</li>
<li>在 LCT 上的所有操作，都只需要在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上操作即可，因为每一棵<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>都会对应<strong>唯一的</strong>一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>。</li>
</ol>
<p>假如我们有这样一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>：</p>
<p><img src="/images/LCT17.png" /></p>
<p>他的虚实链剖分可能长这样（因为虚实链很自由的原因，所以这并不是唯一一种剖分方式）：</p>
<p><img src="/images/LCT18.png" /></p>
<p>虚线边表示<code>虚边</code>，实线边表示<code>实边</code>。</p>
<p>那么根据定义，这棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>对应的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>可能就会是这样的：</p>
<p><img src="/images/LCT19.png" /></p>
<p>那么我们现在就需要思考，<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>是如何实现 动态树
这么一个难题的呢？</p>
<p>我认为，如果只是去讲具体什么 <code>Access</code>
函数的实现之类的，可能并不能算是真正了解 LCT
的原理，我在这里尽量会讲得更清楚。</p>
<h4 id="如何连边">如何连边</h4>
<p>拿这么两棵树举例：</p>
<p><img src="/images/LCT18.png" /> <img src="/images/LCT20.png" /></p>
<p>我们需要把 <span class="math inline">\(G\)</span> 和 <span
class="math inline">\(B\)</span> 连接起来，那么树就变成这个样子：</p>
<p><img src="/images/LCT21.png" /></p>
<p>我们发现蓝色边无论是<code>实边</code>，还是<code>虚边</code>，都是无法建出一棵合法的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的。因此我们要么在<span
class="math inline">\(\textcolor{green}{原树}\)</span>上作出修改，要么在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上做修改。<br />
根据前文所讲，我们只需在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上做修改即可。<br />
那么我们怎么修改呢？</p>
<p>原先两棵树的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>可以是这样的：</p>
<p><img src="/images/LCT19.png" /></p>
<p><img src="/images/LCT22.png" /></p>
<p>那么假如直接连接 <span class="math inline">\(G\)</span> 和 <span
class="math inline">\(B\)</span> 就会是这样的：</p>
<p><img src="/images/LCT23.png" /></p>
<p>很显然的发现，这样是不合法的，因为 <span
class="math inline">\(G\)</span> 有了两个父亲。<br />
根据<span class="math inline">\(\textcolor{blue}{辅助树}\)</span>的性质
<span class="math inline">\(3\)</span>，我们知道，只有整棵<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的根节点才是没有父亲的。<br />
因此我们需要把 <span class="math inline">\(G\)</span>
点变成它所在的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的根的位置。<br />
我们定义一种新的函数叫做 <code>access(x)</code>，表示将 <code>x</code>
这个点与其当前变所在的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的根结点弄到同一个
Splay 中。<br />
那么在这个例子中，我们进行一次 <code>access(G)</code>，再
<code>Splay(G)</code> 一下，最后，连接 <span
class="math inline">\(G\)</span> 和 <span
class="math inline">\(B\)</span>，似乎就达成了任务，此时变为：</p>
<p><img src="/images/LCT24.png" /></p>
<p>但从<span
class="math inline">\(\textcolor{green}{原树}\)</span>的连接情况中我们可以看出：</p>
<p><img src="/images/LCT21.png" /></p>
<p>根据<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的性质 <span
class="math inline">\(2\)</span>，在这棵<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上，<span
class="math inline">\(I,G,H\)</span>
应该深度依次递增。但我们发现在连接后的<span
class="math inline">\(\textcolor{green}{原树}\)</span>上（假设以 <span
class="math inline">\(A\)</span>
点为根）并不满足这一点，因此目前的连接情况是不合法的。<br />
怎么处理这种情况？<br />
那么很显然的，我们让 <span class="math inline">\(G\)</span>
这个点变成它所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根就可以了。<br />
我们称这样将某个点变成其所在的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根的操作为
<code>makeroot(x)</code>，当然，我们只能在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上进行一些操作。<br />
那么这个 <code>makeroot(x)</code> 函数以及前文中的
<code>access(x)</code> 函数分别该怎样实现呢？</p>
<h4 id="access">access</h4>
<p>这里再用上文中的<span
class="math inline">\(\textcolor{green}{原树}\)</span>的例子就不大好了。我们换一棵<span
class="math inline">\(\textcolor{green}{原树}\)</span>：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-1.svg" /></p>
<p>（这里就直接搬了 OI-Wiki 上的原图了xwx）</p>
<p>（这里以 <span class="math inline">\(A\)</span> 点为<span
class="math inline">\(\textcolor{green}{原树}\)</span>的根。）<br />
这棵<span class="math inline">\(\textcolor{green}{原树}\)</span>的<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>可能长这样：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-2.svg" /></p>
<p>假如我们想要 <code>access(N)</code>。</p>
<p>也就是将<span
class="math inline">\(\textcolor{green}{原树}\)</span>变为这样：</p>
<p><img src="https://oi-wiki.org/ds/images/lct-access-3.svg" /></p>
<p>（红色的边表示的是有虚实边类型切换的边）</p>
<p>为了保证<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>的性质，我们需要将原来
<span class="math inline">\(N\)</span> 到 <span
class="math inline">\(O\)</span>
的<code>实边</code>变为<code>虚边</code>。</p>
<p>那么在<span
class="math inline">\(\textcolor{blue}{辅助树}\)</span>上，我们首先需要</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2025 yzljyのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yzljy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="yzljyawa/yzljyawa.github.io"
    data-repo-id="R_kgDOMbAUfA"
    data-category="Announcements"
    data-category-id="DIC_kwDOMbAUfM4CiQYe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
